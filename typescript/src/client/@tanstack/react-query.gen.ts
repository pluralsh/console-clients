// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';
import type { AxiosError } from 'axios';

import { client } from '../client.gen.js';
import { createAgentRun, createAgentSession, createCluster, createClusterUpgrade, createGitRepository, createGlobalService, createScmConnection, createService, createServiceAccountAccessToken, createStack, deleteCatalog, deleteCluster, deleteGitRepository, deleteGlobalService, deleteScmConnection, deleteService, deleteStack, getAgentRun, getAgentRuntime, getAgentSession, getCatalog, getCluster, getClusterUpgrade, getGitRepository, getGitRepositoryByUrl, getGlobalService, getHelmRepository, getHelmRepositoryByUrl, getPipeline, getPrAutomation, getPullRequest, getScmConnection, getSentinel, getSentinelRun, getService, getServiceAccount, getServiceAccountByEmail, getStack, invokePrAutomation, listAgentRuns, listAgentRuntimes, listAgentSessions, listCatalogs, listClusters, listGitRepositories, listGlobalServices, listHelmRepositories, listPipelines, listPrAutomations, listPrAutomationsForCatalog, listProjects, listPullRequests, listScmConnections, listSentinelRuns, listSentinels, listServiceAccounts, listServices, listStacks, me, type Options, restoreStack, resyncStack, syncGlobalService, triggerPipeline, triggerSentinel, triggerStackRun, updateCatalog, updateCluster, updateGitRepository, updateGlobalService, updateScmConnection, updateService, updateStack, upsertCatalog, upsertHelmRepository } from '../sdk.gen.js';
import type { CreateAgentRunData, CreateAgentRunResponse, CreateAgentSessionData, CreateAgentSessionResponse, CreateClusterData, CreateClusterResponse, CreateClusterUpgradeData, CreateClusterUpgradeResponse, CreateGitRepositoryData, CreateGitRepositoryResponse, CreateGlobalServiceData, CreateGlobalServiceResponse, CreateScmConnectionData, CreateScmConnectionResponse, CreateServiceAccountAccessTokenData, CreateServiceAccountAccessTokenResponse, CreateServiceData, CreateServiceResponse, CreateStackData, CreateStackResponse, DeleteCatalogData, DeleteCatalogResponse, DeleteClusterData, DeleteClusterResponse, DeleteGitRepositoryData, DeleteGitRepositoryResponse, DeleteGlobalServiceData, DeleteGlobalServiceResponse, DeleteScmConnectionData, DeleteScmConnectionResponse, DeleteServiceData, DeleteServiceResponse, DeleteStackData, DeleteStackResponse, GetAgentRunData, GetAgentRunResponse, GetAgentRuntimeData, GetAgentRuntimeResponse, GetAgentSessionData, GetAgentSessionResponse, GetCatalogData, GetCatalogResponse, GetClusterData, GetClusterResponse, GetClusterUpgradeData, GetClusterUpgradeResponse, GetGitRepositoryByUrlData, GetGitRepositoryByUrlResponse, GetGitRepositoryData, GetGitRepositoryResponse, GetGlobalServiceData, GetGlobalServiceResponse, GetHelmRepositoryByUrlData, GetHelmRepositoryByUrlResponse, GetHelmRepositoryData, GetHelmRepositoryResponse, GetPipelineData, GetPipelineResponse, GetPrAutomationData, GetPrAutomationResponse, GetPullRequestData, GetPullRequestResponse, GetScmConnectionData, GetScmConnectionResponse, GetSentinelData, GetSentinelResponse, GetSentinelRunData, GetSentinelRunResponse, GetServiceAccountByEmailData, GetServiceAccountByEmailResponse, GetServiceAccountData, GetServiceAccountResponse, GetServiceData, GetServiceResponse, GetStackData, GetStackResponse, InvokePrAutomationData, InvokePrAutomationResponse, ListAgentRunsData, ListAgentRunsResponse, ListAgentRuntimesData, ListAgentRuntimesResponse, ListAgentSessionsData, ListAgentSessionsResponse, ListCatalogsData, ListCatalogsResponse, ListClustersData, ListClustersResponse, ListGitRepositoriesData, ListGitRepositoriesResponse, ListGlobalServicesData, ListGlobalServicesResponse, ListHelmRepositoriesData, ListHelmRepositoriesResponse, ListPipelinesData, ListPipelinesResponse, ListPrAutomationsData, ListPrAutomationsForCatalogData, ListPrAutomationsForCatalogResponse, ListPrAutomationsResponse, ListProjectsData, ListProjectsResponse, ListPullRequestsData, ListPullRequestsResponse, ListScmConnectionsData, ListScmConnectionsResponse, ListSentinelRunsData, ListSentinelRunsResponse, ListSentinelsData, ListSentinelsResponse, ListServiceAccountsData, ListServiceAccountsResponse, ListServicesData, ListServicesResponse, ListStacksData, ListStacksResponse, MeData, MeResponse, RestoreStackData, RestoreStackResponse, ResyncStackData, ResyncStackResponse, SyncGlobalServiceData, SyncGlobalServiceResponse, TriggerPipelineData, TriggerPipelineResponse, TriggerSentinelData, TriggerSentinelResponse, TriggerStackRunData, TriggerStackRunResponse, UpdateCatalogData, UpdateCatalogResponse, UpdateClusterData, UpdateClusterResponse, UpdateGitRepositoryData, UpdateGitRepositoryResponse, UpdateGlobalServiceData, UpdateGlobalServiceResponse, UpdateScmConnectionData, UpdateScmConnectionResponse, UpdateServiceData, UpdateServiceResponse, UpdateStackData, UpdateStackResponse, UpsertCatalogData, UpsertCatalogResponse, UpsertHelmRepositoryData, UpsertHelmRepositoryResponse } from '../types.gen.js';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseURL: options?.baseURL || (options?.client ?? client).getConfig().baseURL } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const listAgentRunsQueryKey = (options?: Options<ListAgentRunsData>) => createQueryKey('listAgentRuns', options);

export const listAgentRunsOptions = (options?: Options<ListAgentRunsData>) => queryOptions<ListAgentRunsResponse, AxiosError<DefaultError>, ListAgentRunsResponse, ReturnType<typeof listAgentRunsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listAgentRuns({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAgentRunsQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = { ...queryKey[0] };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const listAgentRunsInfiniteQueryKey = (options?: Options<ListAgentRunsData>): QueryKey<Options<ListAgentRunsData>> => createQueryKey('listAgentRuns', options, true);

export const listAgentRunsInfiniteOptions = (options?: Options<ListAgentRunsData>) => infiniteQueryOptions<ListAgentRunsResponse, AxiosError<DefaultError>, InfiniteData<ListAgentRunsResponse>, QueryKey<Options<ListAgentRunsData>>, number | Pick<QueryKey<Options<ListAgentRunsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListAgentRunsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listAgentRuns({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAgentRunsInfiniteQueryKey(options)
});

export const createAgentRunMutation = (options?: Partial<Options<CreateAgentRunData>>): UseMutationOptions<CreateAgentRunResponse, AxiosError<DefaultError>, Options<CreateAgentRunData>> => {
    const mutationOptions: UseMutationOptions<CreateAgentRunResponse, AxiosError<DefaultError>, Options<CreateAgentRunData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAgentRun({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAgentRunQueryKey = (options: Options<GetAgentRunData>) => createQueryKey('getAgentRun', options);

export const getAgentRunOptions = (options: Options<GetAgentRunData>) => queryOptions<GetAgentRunResponse, AxiosError<DefaultError>, GetAgentRunResponse, ReturnType<typeof getAgentRunQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAgentRun({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAgentRunQueryKey(options)
});

export const listAgentRuntimesQueryKey = (options?: Options<ListAgentRuntimesData>) => createQueryKey('listAgentRuntimes', options);

export const listAgentRuntimesOptions = (options?: Options<ListAgentRuntimesData>) => queryOptions<ListAgentRuntimesResponse, AxiosError<DefaultError>, ListAgentRuntimesResponse, ReturnType<typeof listAgentRuntimesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listAgentRuntimes({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAgentRuntimesQueryKey(options)
});

export const listAgentRuntimesInfiniteQueryKey = (options?: Options<ListAgentRuntimesData>): QueryKey<Options<ListAgentRuntimesData>> => createQueryKey('listAgentRuntimes', options, true);

export const listAgentRuntimesInfiniteOptions = (options?: Options<ListAgentRuntimesData>) => infiniteQueryOptions<ListAgentRuntimesResponse, AxiosError<DefaultError>, InfiniteData<ListAgentRuntimesResponse>, QueryKey<Options<ListAgentRuntimesData>>, number | Pick<QueryKey<Options<ListAgentRuntimesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListAgentRuntimesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listAgentRuntimes({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAgentRuntimesInfiniteQueryKey(options)
});

export const getAgentRuntimeQueryKey = (options: Options<GetAgentRuntimeData>) => createQueryKey('getAgentRuntime', options);

export const getAgentRuntimeOptions = (options: Options<GetAgentRuntimeData>) => queryOptions<GetAgentRuntimeResponse, AxiosError<DefaultError>, GetAgentRuntimeResponse, ReturnType<typeof getAgentRuntimeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAgentRuntime({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAgentRuntimeQueryKey(options)
});

export const getSentinelRunQueryKey = (options: Options<GetSentinelRunData>) => createQueryKey('getSentinelRun', options);

export const getSentinelRunOptions = (options: Options<GetSentinelRunData>) => queryOptions<GetSentinelRunResponse, AxiosError<DefaultError>, GetSentinelRunResponse, ReturnType<typeof getSentinelRunQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getSentinelRun({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSentinelRunQueryKey(options)
});

export const listSentinelsQueryKey = (options?: Options<ListSentinelsData>) => createQueryKey('listSentinels', options);

export const listSentinelsOptions = (options?: Options<ListSentinelsData>) => queryOptions<ListSentinelsResponse, AxiosError<DefaultError>, ListSentinelsResponse, ReturnType<typeof listSentinelsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listSentinels({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listSentinelsQueryKey(options)
});

export const listSentinelsInfiniteQueryKey = (options?: Options<ListSentinelsData>): QueryKey<Options<ListSentinelsData>> => createQueryKey('listSentinels', options, true);

export const listSentinelsInfiniteOptions = (options?: Options<ListSentinelsData>) => infiniteQueryOptions<ListSentinelsResponse, AxiosError<DefaultError>, InfiniteData<ListSentinelsResponse>, QueryKey<Options<ListSentinelsData>>, number | Pick<QueryKey<Options<ListSentinelsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListSentinelsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listSentinels({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listSentinelsInfiniteQueryKey(options)
});

export const getSentinelQueryKey = (options: Options<GetSentinelData>) => createQueryKey('getSentinel', options);

export const getSentinelOptions = (options: Options<GetSentinelData>) => queryOptions<GetSentinelResponse, AxiosError<DefaultError>, GetSentinelResponse, ReturnType<typeof getSentinelQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getSentinel({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSentinelQueryKey(options)
});

export const triggerSentinelMutation = (options?: Partial<Options<TriggerSentinelData>>): UseMutationOptions<TriggerSentinelResponse, AxiosError<DefaultError>, Options<TriggerSentinelData>> => {
    const mutationOptions: UseMutationOptions<TriggerSentinelResponse, AxiosError<DefaultError>, Options<TriggerSentinelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await triggerSentinel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listSentinelRunsQueryKey = (options: Options<ListSentinelRunsData>) => createQueryKey('listSentinelRuns', options);

export const listSentinelRunsOptions = (options: Options<ListSentinelRunsData>) => queryOptions<ListSentinelRunsResponse, AxiosError<DefaultError>, ListSentinelRunsResponse, ReturnType<typeof listSentinelRunsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listSentinelRuns({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listSentinelRunsQueryKey(options)
});

export const listSentinelRunsInfiniteQueryKey = (options: Options<ListSentinelRunsData>): QueryKey<Options<ListSentinelRunsData>> => createQueryKey('listSentinelRuns', options, true);

export const listSentinelRunsInfiniteOptions = (options: Options<ListSentinelRunsData>) => infiniteQueryOptions<ListSentinelRunsResponse, AxiosError<DefaultError>, InfiniteData<ListSentinelRunsResponse>, QueryKey<Options<ListSentinelRunsData>>, number | Pick<QueryKey<Options<ListSentinelRunsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListSentinelRunsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listSentinelRuns({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listSentinelRunsInfiniteQueryKey(options)
});

export const listAgentSessionsQueryKey = (options?: Options<ListAgentSessionsData>) => createQueryKey('listAgentSessions', options);

export const listAgentSessionsOptions = (options?: Options<ListAgentSessionsData>) => queryOptions<ListAgentSessionsResponse, AxiosError<DefaultError>, ListAgentSessionsResponse, ReturnType<typeof listAgentSessionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listAgentSessions({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAgentSessionsQueryKey(options)
});

export const listAgentSessionsInfiniteQueryKey = (options?: Options<ListAgentSessionsData>): QueryKey<Options<ListAgentSessionsData>> => createQueryKey('listAgentSessions', options, true);

export const listAgentSessionsInfiniteOptions = (options?: Options<ListAgentSessionsData>) => infiniteQueryOptions<ListAgentSessionsResponse, AxiosError<DefaultError>, InfiniteData<ListAgentSessionsResponse>, QueryKey<Options<ListAgentSessionsData>>, number | Pick<QueryKey<Options<ListAgentSessionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListAgentSessionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listAgentSessions({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAgentSessionsInfiniteQueryKey(options)
});

export const createAgentSessionMutation = (options?: Partial<Options<CreateAgentSessionData>>): UseMutationOptions<CreateAgentSessionResponse, AxiosError<DefaultError>, Options<CreateAgentSessionData>> => {
    const mutationOptions: UseMutationOptions<CreateAgentSessionResponse, AxiosError<DefaultError>, Options<CreateAgentSessionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAgentSession({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAgentSessionQueryKey = (options: Options<GetAgentSessionData>) => createQueryKey('getAgentSession', options);

export const getAgentSessionOptions = (options: Options<GetAgentSessionData>) => queryOptions<GetAgentSessionResponse, AxiosError<DefaultError>, GetAgentSessionResponse, ReturnType<typeof getAgentSessionQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAgentSession({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAgentSessionQueryKey(options)
});

export const listClustersQueryKey = (options?: Options<ListClustersData>) => createQueryKey('listClusters', options);

export const listClustersOptions = (options?: Options<ListClustersData>) => queryOptions<ListClustersResponse, AxiosError<DefaultError>, ListClustersResponse, ReturnType<typeof listClustersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listClusters({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listClustersQueryKey(options)
});

export const listClustersInfiniteQueryKey = (options?: Options<ListClustersData>): QueryKey<Options<ListClustersData>> => createQueryKey('listClusters', options, true);

export const listClustersInfiniteOptions = (options?: Options<ListClustersData>) => infiniteQueryOptions<ListClustersResponse, AxiosError<DefaultError>, InfiniteData<ListClustersResponse>, QueryKey<Options<ListClustersData>>, number | Pick<QueryKey<Options<ListClustersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListClustersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listClusters({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listClustersInfiniteQueryKey(options)
});

export const createClusterMutation = (options?: Partial<Options<CreateClusterData>>): UseMutationOptions<CreateClusterResponse, AxiosError<DefaultError>, Options<CreateClusterData>> => {
    const mutationOptions: UseMutationOptions<CreateClusterResponse, AxiosError<DefaultError>, Options<CreateClusterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createCluster({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteClusterMutation = (options?: Partial<Options<DeleteClusterData>>): UseMutationOptions<DeleteClusterResponse, AxiosError<DefaultError>, Options<DeleteClusterData>> => {
    const mutationOptions: UseMutationOptions<DeleteClusterResponse, AxiosError<DefaultError>, Options<DeleteClusterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCluster({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getClusterQueryKey = (options: Options<GetClusterData>) => createQueryKey('getCluster', options);

export const getClusterOptions = (options: Options<GetClusterData>) => queryOptions<GetClusterResponse, AxiosError<DefaultError>, GetClusterResponse, ReturnType<typeof getClusterQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCluster({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getClusterQueryKey(options)
});

export const updateClusterMutation = (options?: Partial<Options<UpdateClusterData>>): UseMutationOptions<UpdateClusterResponse, AxiosError<DefaultError>, Options<UpdateClusterData>> => {
    const mutationOptions: UseMutationOptions<UpdateClusterResponse, AxiosError<DefaultError>, Options<UpdateClusterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateCluster({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createClusterUpgradeMutation = (options?: Partial<Options<CreateClusterUpgradeData>>): UseMutationOptions<CreateClusterUpgradeResponse, AxiosError<DefaultError>, Options<CreateClusterUpgradeData>> => {
    const mutationOptions: UseMutationOptions<CreateClusterUpgradeResponse, AxiosError<DefaultError>, Options<CreateClusterUpgradeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createClusterUpgrade({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getClusterUpgradeQueryKey = (options: Options<GetClusterUpgradeData>) => createQueryKey('getClusterUpgrade', options);

export const getClusterUpgradeOptions = (options: Options<GetClusterUpgradeData>) => queryOptions<GetClusterUpgradeResponse, AxiosError<DefaultError>, GetClusterUpgradeResponse, ReturnType<typeof getClusterUpgradeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getClusterUpgrade({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getClusterUpgradeQueryKey(options)
});

export const listGitRepositoriesQueryKey = (options?: Options<ListGitRepositoriesData>) => createQueryKey('listGitRepositories', options);

export const listGitRepositoriesOptions = (options?: Options<ListGitRepositoriesData>) => queryOptions<ListGitRepositoriesResponse, AxiosError<DefaultError>, ListGitRepositoriesResponse, ReturnType<typeof listGitRepositoriesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listGitRepositories({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listGitRepositoriesQueryKey(options)
});

export const listGitRepositoriesInfiniteQueryKey = (options?: Options<ListGitRepositoriesData>): QueryKey<Options<ListGitRepositoriesData>> => createQueryKey('listGitRepositories', options, true);

export const listGitRepositoriesInfiniteOptions = (options?: Options<ListGitRepositoriesData>) => infiniteQueryOptions<ListGitRepositoriesResponse, AxiosError<DefaultError>, InfiniteData<ListGitRepositoriesResponse>, QueryKey<Options<ListGitRepositoriesData>>, number | Pick<QueryKey<Options<ListGitRepositoriesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListGitRepositoriesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listGitRepositories({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listGitRepositoriesInfiniteQueryKey(options)
});

export const createGitRepositoryMutation = (options?: Partial<Options<CreateGitRepositoryData>>): UseMutationOptions<CreateGitRepositoryResponse, AxiosError<DefaultError>, Options<CreateGitRepositoryData>> => {
    const mutationOptions: UseMutationOptions<CreateGitRepositoryResponse, AxiosError<DefaultError>, Options<CreateGitRepositoryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createGitRepository({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getGitRepositoryByUrlQueryKey = (options: Options<GetGitRepositoryByUrlData>) => createQueryKey('getGitRepositoryByUrl', options);

export const getGitRepositoryByUrlOptions = (options: Options<GetGitRepositoryByUrlData>) => queryOptions<GetGitRepositoryByUrlResponse, AxiosError<DefaultError>, GetGitRepositoryByUrlResponse, ReturnType<typeof getGitRepositoryByUrlQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getGitRepositoryByUrl({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getGitRepositoryByUrlQueryKey(options)
});

export const deleteGitRepositoryMutation = (options?: Partial<Options<DeleteGitRepositoryData>>): UseMutationOptions<DeleteGitRepositoryResponse, AxiosError<DefaultError>, Options<DeleteGitRepositoryData>> => {
    const mutationOptions: UseMutationOptions<DeleteGitRepositoryResponse, AxiosError<DefaultError>, Options<DeleteGitRepositoryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteGitRepository({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getGitRepositoryQueryKey = (options: Options<GetGitRepositoryData>) => createQueryKey('getGitRepository', options);

export const getGitRepositoryOptions = (options: Options<GetGitRepositoryData>) => queryOptions<GetGitRepositoryResponse, AxiosError<DefaultError>, GetGitRepositoryResponse, ReturnType<typeof getGitRepositoryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getGitRepository({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getGitRepositoryQueryKey(options)
});

export const updateGitRepositoryMutation = (options?: Partial<Options<UpdateGitRepositoryData>>): UseMutationOptions<UpdateGitRepositoryResponse, AxiosError<DefaultError>, Options<UpdateGitRepositoryData>> => {
    const mutationOptions: UseMutationOptions<UpdateGitRepositoryResponse, AxiosError<DefaultError>, Options<UpdateGitRepositoryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateGitRepository({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listGlobalServicesQueryKey = (options?: Options<ListGlobalServicesData>) => createQueryKey('listGlobalServices', options);

export const listGlobalServicesOptions = (options?: Options<ListGlobalServicesData>) => queryOptions<ListGlobalServicesResponse, AxiosError<DefaultError>, ListGlobalServicesResponse, ReturnType<typeof listGlobalServicesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listGlobalServices({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listGlobalServicesQueryKey(options)
});

export const listGlobalServicesInfiniteQueryKey = (options?: Options<ListGlobalServicesData>): QueryKey<Options<ListGlobalServicesData>> => createQueryKey('listGlobalServices', options, true);

export const listGlobalServicesInfiniteOptions = (options?: Options<ListGlobalServicesData>) => infiniteQueryOptions<ListGlobalServicesResponse, AxiosError<DefaultError>, InfiniteData<ListGlobalServicesResponse>, QueryKey<Options<ListGlobalServicesData>>, number | Pick<QueryKey<Options<ListGlobalServicesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListGlobalServicesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listGlobalServices({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listGlobalServicesInfiniteQueryKey(options)
});

export const createGlobalServiceMutation = (options?: Partial<Options<CreateGlobalServiceData>>): UseMutationOptions<CreateGlobalServiceResponse, AxiosError<DefaultError>, Options<CreateGlobalServiceData>> => {
    const mutationOptions: UseMutationOptions<CreateGlobalServiceResponse, AxiosError<DefaultError>, Options<CreateGlobalServiceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createGlobalService({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteGlobalServiceMutation = (options?: Partial<Options<DeleteGlobalServiceData>>): UseMutationOptions<DeleteGlobalServiceResponse, AxiosError<DefaultError>, Options<DeleteGlobalServiceData>> => {
    const mutationOptions: UseMutationOptions<DeleteGlobalServiceResponse, AxiosError<DefaultError>, Options<DeleteGlobalServiceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteGlobalService({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getGlobalServiceQueryKey = (options: Options<GetGlobalServiceData>) => createQueryKey('getGlobalService', options);

export const getGlobalServiceOptions = (options: Options<GetGlobalServiceData>) => queryOptions<GetGlobalServiceResponse, AxiosError<DefaultError>, GetGlobalServiceResponse, ReturnType<typeof getGlobalServiceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getGlobalService({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getGlobalServiceQueryKey(options)
});

export const updateGlobalServiceMutation = (options?: Partial<Options<UpdateGlobalServiceData>>): UseMutationOptions<UpdateGlobalServiceResponse, AxiosError<DefaultError>, Options<UpdateGlobalServiceData>> => {
    const mutationOptions: UseMutationOptions<UpdateGlobalServiceResponse, AxiosError<DefaultError>, Options<UpdateGlobalServiceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateGlobalService({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const syncGlobalServiceMutation = (options?: Partial<Options<SyncGlobalServiceData>>): UseMutationOptions<SyncGlobalServiceResponse, AxiosError<DefaultError>, Options<SyncGlobalServiceData>> => {
    const mutationOptions: UseMutationOptions<SyncGlobalServiceResponse, AxiosError<DefaultError>, Options<SyncGlobalServiceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await syncGlobalService({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listHelmRepositoriesQueryKey = (options?: Options<ListHelmRepositoriesData>) => createQueryKey('listHelmRepositories', options);

export const listHelmRepositoriesOptions = (options?: Options<ListHelmRepositoriesData>) => queryOptions<ListHelmRepositoriesResponse, AxiosError<DefaultError>, ListHelmRepositoriesResponse, ReturnType<typeof listHelmRepositoriesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listHelmRepositories({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listHelmRepositoriesQueryKey(options)
});

export const listHelmRepositoriesInfiniteQueryKey = (options?: Options<ListHelmRepositoriesData>): QueryKey<Options<ListHelmRepositoriesData>> => createQueryKey('listHelmRepositories', options, true);

export const listHelmRepositoriesInfiniteOptions = (options?: Options<ListHelmRepositoriesData>) => infiniteQueryOptions<ListHelmRepositoriesResponse, AxiosError<DefaultError>, InfiniteData<ListHelmRepositoriesResponse>, QueryKey<Options<ListHelmRepositoriesData>>, number | Pick<QueryKey<Options<ListHelmRepositoriesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListHelmRepositoriesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listHelmRepositories({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listHelmRepositoriesInfiniteQueryKey(options)
});

export const upsertHelmRepositoryMutation = (options?: Partial<Options<UpsertHelmRepositoryData>>): UseMutationOptions<UpsertHelmRepositoryResponse, AxiosError<DefaultError>, Options<UpsertHelmRepositoryData>> => {
    const mutationOptions: UseMutationOptions<UpsertHelmRepositoryResponse, AxiosError<DefaultError>, Options<UpsertHelmRepositoryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await upsertHelmRepository({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getHelmRepositoryByUrlQueryKey = (options: Options<GetHelmRepositoryByUrlData>) => createQueryKey('getHelmRepositoryByUrl', options);

export const getHelmRepositoryByUrlOptions = (options: Options<GetHelmRepositoryByUrlData>) => queryOptions<GetHelmRepositoryByUrlResponse, AxiosError<DefaultError>, GetHelmRepositoryByUrlResponse, ReturnType<typeof getHelmRepositoryByUrlQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getHelmRepositoryByUrl({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getHelmRepositoryByUrlQueryKey(options)
});

export const getHelmRepositoryQueryKey = (options: Options<GetHelmRepositoryData>) => createQueryKey('getHelmRepository', options);

export const getHelmRepositoryOptions = (options: Options<GetHelmRepositoryData>) => queryOptions<GetHelmRepositoryResponse, AxiosError<DefaultError>, GetHelmRepositoryResponse, ReturnType<typeof getHelmRepositoryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getHelmRepository({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getHelmRepositoryQueryKey(options)
});

export const listPipelinesQueryKey = (options?: Options<ListPipelinesData>) => createQueryKey('listPipelines', options);

/**
 * List all pipelines
 *
 * Returns a paginated list of all pipelines the authenticated user has access to
 */
export const listPipelinesOptions = (options?: Options<ListPipelinesData>) => queryOptions<ListPipelinesResponse, AxiosError<DefaultError>, ListPipelinesResponse, ReturnType<typeof listPipelinesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listPipelines({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listPipelinesQueryKey(options)
});

export const listPipelinesInfiniteQueryKey = (options?: Options<ListPipelinesData>): QueryKey<Options<ListPipelinesData>> => createQueryKey('listPipelines', options, true);

/**
 * List all pipelines
 *
 * Returns a paginated list of all pipelines the authenticated user has access to
 */
export const listPipelinesInfiniteOptions = (options?: Options<ListPipelinesData>) => infiniteQueryOptions<ListPipelinesResponse, AxiosError<DefaultError>, InfiniteData<ListPipelinesResponse>, QueryKey<Options<ListPipelinesData>>, number | Pick<QueryKey<Options<ListPipelinesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListPipelinesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listPipelines({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listPipelinesInfiniteQueryKey(options)
});

export const getPipelineQueryKey = (options: Options<GetPipelineData>) => createQueryKey('getPipeline', options);

/**
 * Get a pipeline by ID
 *
 * Retrieves a single pipeline by its unique identifier, including its stages, edges, and gates
 */
export const getPipelineOptions = (options: Options<GetPipelineData>) => queryOptions<GetPipelineResponse, AxiosError<DefaultError>, GetPipelineResponse, ReturnType<typeof getPipelineQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPipeline({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPipelineQueryKey(options)
});

/**
 * Trigger a pipeline run
 *
 * Creates a new pipeline context to trigger a pipeline run. The context data flows through stages and can be used for PR automations.
 */
export const triggerPipelineMutation = (options?: Partial<Options<TriggerPipelineData>>): UseMutationOptions<TriggerPipelineResponse, AxiosError<DefaultError>, Options<TriggerPipelineData>> => {
    const mutationOptions: UseMutationOptions<TriggerPipelineResponse, AxiosError<DefaultError>, Options<TriggerPipelineData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await triggerPipeline({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listServicesQueryKey = (options?: Options<ListServicesData>) => createQueryKey('listServices', options);

export const listServicesOptions = (options?: Options<ListServicesData>) => queryOptions<ListServicesResponse, AxiosError<DefaultError>, ListServicesResponse, ReturnType<typeof listServicesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listServices({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listServicesQueryKey(options)
});

export const listServicesInfiniteQueryKey = (options?: Options<ListServicesData>): QueryKey<Options<ListServicesData>> => createQueryKey('listServices', options, true);

export const listServicesInfiniteOptions = (options?: Options<ListServicesData>) => infiniteQueryOptions<ListServicesResponse, AxiosError<DefaultError>, InfiniteData<ListServicesResponse>, QueryKey<Options<ListServicesData>>, number | Pick<QueryKey<Options<ListServicesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListServicesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listServices({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listServicesInfiniteQueryKey(options)
});

export const createServiceMutation = (options?: Partial<Options<CreateServiceData>>): UseMutationOptions<CreateServiceResponse, AxiosError<DefaultError>, Options<CreateServiceData>> => {
    const mutationOptions: UseMutationOptions<CreateServiceResponse, AxiosError<DefaultError>, Options<CreateServiceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createService({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteServiceMutation = (options?: Partial<Options<DeleteServiceData>>): UseMutationOptions<DeleteServiceResponse, AxiosError<DefaultError>, Options<DeleteServiceData>> => {
    const mutationOptions: UseMutationOptions<DeleteServiceResponse, AxiosError<DefaultError>, Options<DeleteServiceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteService({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getServiceQueryKey = (options: Options<GetServiceData>) => createQueryKey('getService', options);

export const getServiceOptions = (options: Options<GetServiceData>) => queryOptions<GetServiceResponse, AxiosError<DefaultError>, GetServiceResponse, ReturnType<typeof getServiceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getService({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceQueryKey(options)
});

export const updateServiceMutation = (options?: Partial<Options<UpdateServiceData>>): UseMutationOptions<UpdateServiceResponse, AxiosError<DefaultError>, Options<UpdateServiceData>> => {
    const mutationOptions: UseMutationOptions<UpdateServiceResponse, AxiosError<DefaultError>, Options<UpdateServiceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateService({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const meQueryKey = (options?: Options<MeData>) => createQueryKey('me', options);

export const meOptions = (options?: Options<MeData>) => queryOptions<MeResponse, AxiosError<DefaultError>, MeResponse, ReturnType<typeof meQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await me({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: meQueryKey(options)
});

export const listProjectsQueryKey = (options?: Options<ListProjectsData>) => createQueryKey('listProjects', options);

/**
 * List all projects
 *
 * Returns a paginated list of all projects the authenticated user has access to
 */
export const listProjectsOptions = (options?: Options<ListProjectsData>) => queryOptions<ListProjectsResponse, AxiosError<DefaultError>, ListProjectsResponse, ReturnType<typeof listProjectsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listProjects({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listProjectsQueryKey(options)
});

export const listProjectsInfiniteQueryKey = (options?: Options<ListProjectsData>): QueryKey<Options<ListProjectsData>> => createQueryKey('listProjects', options, true);

/**
 * List all projects
 *
 * Returns a paginated list of all projects the authenticated user has access to
 */
export const listProjectsInfiniteOptions = (options?: Options<ListProjectsData>) => infiniteQueryOptions<ListProjectsResponse, AxiosError<DefaultError>, InfiniteData<ListProjectsResponse>, QueryKey<Options<ListProjectsData>>, number | Pick<QueryKey<Options<ListProjectsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListProjectsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listProjects({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listProjectsInfiniteQueryKey(options)
});

export const listCatalogsQueryKey = (options?: Options<ListCatalogsData>) => createQueryKey('listCatalogs', options);

export const listCatalogsOptions = (options?: Options<ListCatalogsData>) => queryOptions<ListCatalogsResponse, AxiosError<DefaultError>, ListCatalogsResponse, ReturnType<typeof listCatalogsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listCatalogs({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listCatalogsQueryKey(options)
});

export const listCatalogsInfiniteQueryKey = (options?: Options<ListCatalogsData>): QueryKey<Options<ListCatalogsData>> => createQueryKey('listCatalogs', options, true);

export const listCatalogsInfiniteOptions = (options?: Options<ListCatalogsData>) => infiniteQueryOptions<ListCatalogsResponse, AxiosError<DefaultError>, InfiniteData<ListCatalogsResponse>, QueryKey<Options<ListCatalogsData>>, number | Pick<QueryKey<Options<ListCatalogsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListCatalogsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listCatalogs({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listCatalogsInfiniteQueryKey(options)
});

export const upsertCatalogMutation = (options?: Partial<Options<UpsertCatalogData>>): UseMutationOptions<UpsertCatalogResponse, AxiosError<DefaultError>, Options<UpsertCatalogData>> => {
    const mutationOptions: UseMutationOptions<UpsertCatalogResponse, AxiosError<DefaultError>, Options<UpsertCatalogData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await upsertCatalog({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listPrAutomationsForCatalogQueryKey = (options: Options<ListPrAutomationsForCatalogData>) => createQueryKey('listPrAutomationsForCatalog', options);

export const listPrAutomationsForCatalogOptions = (options: Options<ListPrAutomationsForCatalogData>) => queryOptions<ListPrAutomationsForCatalogResponse, AxiosError<DefaultError>, ListPrAutomationsForCatalogResponse, ReturnType<typeof listPrAutomationsForCatalogQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listPrAutomationsForCatalog({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listPrAutomationsForCatalogQueryKey(options)
});

export const listPrAutomationsForCatalogInfiniteQueryKey = (options: Options<ListPrAutomationsForCatalogData>): QueryKey<Options<ListPrAutomationsForCatalogData>> => createQueryKey('listPrAutomationsForCatalog', options, true);

export const listPrAutomationsForCatalogInfiniteOptions = (options: Options<ListPrAutomationsForCatalogData>) => infiniteQueryOptions<ListPrAutomationsForCatalogResponse, AxiosError<DefaultError>, InfiniteData<ListPrAutomationsForCatalogResponse>, QueryKey<Options<ListPrAutomationsForCatalogData>>, number | Pick<QueryKey<Options<ListPrAutomationsForCatalogData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListPrAutomationsForCatalogData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listPrAutomationsForCatalog({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listPrAutomationsForCatalogInfiniteQueryKey(options)
});

export const deleteCatalogMutation = (options?: Partial<Options<DeleteCatalogData>>): UseMutationOptions<DeleteCatalogResponse, AxiosError<DefaultError>, Options<DeleteCatalogData>> => {
    const mutationOptions: UseMutationOptions<DeleteCatalogResponse, AxiosError<DefaultError>, Options<DeleteCatalogData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCatalog({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCatalogQueryKey = (options: Options<GetCatalogData>) => createQueryKey('getCatalog', options);

export const getCatalogOptions = (options: Options<GetCatalogData>) => queryOptions<GetCatalogResponse, AxiosError<DefaultError>, GetCatalogResponse, ReturnType<typeof getCatalogQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCatalog({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCatalogQueryKey(options)
});

export const updateCatalogMutation = (options?: Partial<Options<UpdateCatalogData>>): UseMutationOptions<UpdateCatalogResponse, AxiosError<DefaultError>, Options<UpdateCatalogData>> => {
    const mutationOptions: UseMutationOptions<UpdateCatalogResponse, AxiosError<DefaultError>, Options<UpdateCatalogData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateCatalog({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listScmConnectionsQueryKey = (options?: Options<ListScmConnectionsData>) => createQueryKey('listScmConnections', options);

export const listScmConnectionsOptions = (options?: Options<ListScmConnectionsData>) => queryOptions<ListScmConnectionsResponse, AxiosError<DefaultError>, ListScmConnectionsResponse, ReturnType<typeof listScmConnectionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listScmConnections({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listScmConnectionsQueryKey(options)
});

export const listScmConnectionsInfiniteQueryKey = (options?: Options<ListScmConnectionsData>): QueryKey<Options<ListScmConnectionsData>> => createQueryKey('listScmConnections', options, true);

export const listScmConnectionsInfiniteOptions = (options?: Options<ListScmConnectionsData>) => infiniteQueryOptions<ListScmConnectionsResponse, AxiosError<DefaultError>, InfiniteData<ListScmConnectionsResponse>, QueryKey<Options<ListScmConnectionsData>>, number | Pick<QueryKey<Options<ListScmConnectionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListScmConnectionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listScmConnections({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listScmConnectionsInfiniteQueryKey(options)
});

export const createScmConnectionMutation = (options?: Partial<Options<CreateScmConnectionData>>): UseMutationOptions<CreateScmConnectionResponse, AxiosError<DefaultError>, Options<CreateScmConnectionData>> => {
    const mutationOptions: UseMutationOptions<CreateScmConnectionResponse, AxiosError<DefaultError>, Options<CreateScmConnectionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createScmConnection({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteScmConnectionMutation = (options?: Partial<Options<DeleteScmConnectionData>>): UseMutationOptions<DeleteScmConnectionResponse, AxiosError<DefaultError>, Options<DeleteScmConnectionData>> => {
    const mutationOptions: UseMutationOptions<DeleteScmConnectionResponse, AxiosError<DefaultError>, Options<DeleteScmConnectionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteScmConnection({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getScmConnectionQueryKey = (options: Options<GetScmConnectionData>) => createQueryKey('getScmConnection', options);

export const getScmConnectionOptions = (options: Options<GetScmConnectionData>) => queryOptions<GetScmConnectionResponse, AxiosError<DefaultError>, GetScmConnectionResponse, ReturnType<typeof getScmConnectionQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getScmConnection({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getScmConnectionQueryKey(options)
});

export const updateScmConnectionMutation = (options?: Partial<Options<UpdateScmConnectionData>>): UseMutationOptions<UpdateScmConnectionResponse, AxiosError<DefaultError>, Options<UpdateScmConnectionData>> => {
    const mutationOptions: UseMutationOptions<UpdateScmConnectionResponse, AxiosError<DefaultError>, Options<UpdateScmConnectionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateScmConnection({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listPrAutomationsQueryKey = (options?: Options<ListPrAutomationsData>) => createQueryKey('listPrAutomations', options);

export const listPrAutomationsOptions = (options?: Options<ListPrAutomationsData>) => queryOptions<ListPrAutomationsResponse, AxiosError<DefaultError>, ListPrAutomationsResponse, ReturnType<typeof listPrAutomationsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listPrAutomations({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listPrAutomationsQueryKey(options)
});

export const listPrAutomationsInfiniteQueryKey = (options?: Options<ListPrAutomationsData>): QueryKey<Options<ListPrAutomationsData>> => createQueryKey('listPrAutomations', options, true);

export const listPrAutomationsInfiniteOptions = (options?: Options<ListPrAutomationsData>) => infiniteQueryOptions<ListPrAutomationsResponse, AxiosError<DefaultError>, InfiniteData<ListPrAutomationsResponse>, QueryKey<Options<ListPrAutomationsData>>, number | Pick<QueryKey<Options<ListPrAutomationsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListPrAutomationsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listPrAutomations({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listPrAutomationsInfiniteQueryKey(options)
});

export const getPrAutomationQueryKey = (options: Options<GetPrAutomationData>) => createQueryKey('getPrAutomation', options);

export const getPrAutomationOptions = (options: Options<GetPrAutomationData>) => queryOptions<GetPrAutomationResponse, AxiosError<DefaultError>, GetPrAutomationResponse, ReturnType<typeof getPrAutomationQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPrAutomation({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPrAutomationQueryKey(options)
});

export const invokePrAutomationMutation = (options?: Partial<Options<InvokePrAutomationData>>): UseMutationOptions<InvokePrAutomationResponse, AxiosError<DefaultError>, Options<InvokePrAutomationData>> => {
    const mutationOptions: UseMutationOptions<InvokePrAutomationResponse, AxiosError<DefaultError>, Options<InvokePrAutomationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await invokePrAutomation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listPullRequestsQueryKey = (options?: Options<ListPullRequestsData>) => createQueryKey('listPullRequests', options);

export const listPullRequestsOptions = (options?: Options<ListPullRequestsData>) => queryOptions<ListPullRequestsResponse, AxiosError<DefaultError>, ListPullRequestsResponse, ReturnType<typeof listPullRequestsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listPullRequests({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listPullRequestsQueryKey(options)
});

export const listPullRequestsInfiniteQueryKey = (options?: Options<ListPullRequestsData>): QueryKey<Options<ListPullRequestsData>> => createQueryKey('listPullRequests', options, true);

export const listPullRequestsInfiniteOptions = (options?: Options<ListPullRequestsData>) => infiniteQueryOptions<ListPullRequestsResponse, AxiosError<DefaultError>, InfiniteData<ListPullRequestsResponse>, QueryKey<Options<ListPullRequestsData>>, number | Pick<QueryKey<Options<ListPullRequestsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListPullRequestsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listPullRequests({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listPullRequestsInfiniteQueryKey(options)
});

export const getPullRequestQueryKey = (options: Options<GetPullRequestData>) => createQueryKey('getPullRequest', options);

export const getPullRequestOptions = (options: Options<GetPullRequestData>) => queryOptions<GetPullRequestResponse, AxiosError<DefaultError>, GetPullRequestResponse, ReturnType<typeof getPullRequestQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPullRequest({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPullRequestQueryKey(options)
});

export const listServiceAccountsQueryKey = (options?: Options<ListServiceAccountsData>) => createQueryKey('listServiceAccounts', options);

export const listServiceAccountsOptions = (options?: Options<ListServiceAccountsData>) => queryOptions<ListServiceAccountsResponse, AxiosError<DefaultError>, ListServiceAccountsResponse, ReturnType<typeof listServiceAccountsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listServiceAccounts({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listServiceAccountsQueryKey(options)
});

export const listServiceAccountsInfiniteQueryKey = (options?: Options<ListServiceAccountsData>): QueryKey<Options<ListServiceAccountsData>> => createQueryKey('listServiceAccounts', options, true);

export const listServiceAccountsInfiniteOptions = (options?: Options<ListServiceAccountsData>) => infiniteQueryOptions<ListServiceAccountsResponse, AxiosError<DefaultError>, InfiniteData<ListServiceAccountsResponse>, QueryKey<Options<ListServiceAccountsData>>, number | Pick<QueryKey<Options<ListServiceAccountsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListServiceAccountsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listServiceAccounts({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listServiceAccountsInfiniteQueryKey(options)
});

export const getServiceAccountByEmailQueryKey = (options: Options<GetServiceAccountByEmailData>) => createQueryKey('getServiceAccountByEmail', options);

export const getServiceAccountByEmailOptions = (options: Options<GetServiceAccountByEmailData>) => queryOptions<GetServiceAccountByEmailResponse, AxiosError<DefaultError>, GetServiceAccountByEmailResponse, ReturnType<typeof getServiceAccountByEmailQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getServiceAccountByEmail({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceAccountByEmailQueryKey(options)
});

export const getServiceAccountQueryKey = (options: Options<GetServiceAccountData>) => createQueryKey('getServiceAccount', options);

export const getServiceAccountOptions = (options: Options<GetServiceAccountData>) => queryOptions<GetServiceAccountResponse, AxiosError<DefaultError>, GetServiceAccountResponse, ReturnType<typeof getServiceAccountQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getServiceAccount({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceAccountQueryKey(options)
});

export const createServiceAccountAccessTokenMutation = (options?: Partial<Options<CreateServiceAccountAccessTokenData>>): UseMutationOptions<CreateServiceAccountAccessTokenResponse, AxiosError<DefaultError>, Options<CreateServiceAccountAccessTokenData>> => {
    const mutationOptions: UseMutationOptions<CreateServiceAccountAccessTokenResponse, AxiosError<DefaultError>, Options<CreateServiceAccountAccessTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createServiceAccountAccessToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listStacksQueryKey = (options?: Options<ListStacksData>) => createQueryKey('listStacks', options);

export const listStacksOptions = (options?: Options<ListStacksData>) => queryOptions<ListStacksResponse, AxiosError<DefaultError>, ListStacksResponse, ReturnType<typeof listStacksQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listStacks({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listStacksQueryKey(options)
});

export const listStacksInfiniteQueryKey = (options?: Options<ListStacksData>): QueryKey<Options<ListStacksData>> => createQueryKey('listStacks', options, true);

export const listStacksInfiniteOptions = (options?: Options<ListStacksData>) => infiniteQueryOptions<ListStacksResponse, AxiosError<DefaultError>, InfiniteData<ListStacksResponse>, QueryKey<Options<ListStacksData>>, number | Pick<QueryKey<Options<ListStacksData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListStacksData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listStacks({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listStacksInfiniteQueryKey(options)
});

export const createStackMutation = (options?: Partial<Options<CreateStackData>>): UseMutationOptions<CreateStackResponse, AxiosError<DefaultError>, Options<CreateStackData>> => {
    const mutationOptions: UseMutationOptions<CreateStackResponse, AxiosError<DefaultError>, Options<CreateStackData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createStack({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteStackMutation = (options?: Partial<Options<DeleteStackData>>): UseMutationOptions<DeleteStackResponse, AxiosError<DefaultError>, Options<DeleteStackData>> => {
    const mutationOptions: UseMutationOptions<DeleteStackResponse, AxiosError<DefaultError>, Options<DeleteStackData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteStack({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getStackQueryKey = (options: Options<GetStackData>) => createQueryKey('getStack', options);

export const getStackOptions = (options: Options<GetStackData>) => queryOptions<GetStackResponse, AxiosError<DefaultError>, GetStackResponse, ReturnType<typeof getStackQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getStack({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStackQueryKey(options)
});

export const updateStackMutation = (options?: Partial<Options<UpdateStackData>>): UseMutationOptions<UpdateStackResponse, AxiosError<DefaultError>, Options<UpdateStackData>> => {
    const mutationOptions: UseMutationOptions<UpdateStackResponse, AxiosError<DefaultError>, Options<UpdateStackData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateStack({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const restoreStackMutation = (options?: Partial<Options<RestoreStackData>>): UseMutationOptions<RestoreStackResponse, AxiosError<DefaultError>, Options<RestoreStackData>> => {
    const mutationOptions: UseMutationOptions<RestoreStackResponse, AxiosError<DefaultError>, Options<RestoreStackData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await restoreStack({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resyncStackMutation = (options?: Partial<Options<ResyncStackData>>): UseMutationOptions<ResyncStackResponse, AxiosError<DefaultError>, Options<ResyncStackData>> => {
    const mutationOptions: UseMutationOptions<ResyncStackResponse, AxiosError<DefaultError>, Options<ResyncStackData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await resyncStack({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const triggerStackRunMutation = (options?: Partial<Options<TriggerStackRunData>>): UseMutationOptions<TriggerStackRunResponse, AxiosError<DefaultError>, Options<TriggerStackRunData>> => {
    const mutationOptions: UseMutationOptions<TriggerStackRunResponse, AxiosError<DefaultError>, Options<TriggerStackRunData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await triggerStackRun({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};
