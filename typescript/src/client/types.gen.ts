// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseURL: 'https://localhost/' | (string & {});
};

/**
 * AccessToken
 *
 * An access token
 */
export type AccessToken = {
    expires_at?: string;
    id: string;
    inserted_at: string;
    last_used_at?: string;
    scopes?: Array<ConsoleOpenApiAccessTokenScope>;
    token: string;
    updated_at?: string;
};

/**
 * AccessTokenInput
 *
 * Input for creating a service account access token
 */
export type AccessTokenInput = {
    /**
     * Token TTL, e.g. 1h, 1d, 1w
     */
    expiry?: string;
    scopes?: Array<ConsoleOpenApiAccessTokenScope>;
};

/**
 * AgentRun
 *
 * An execution of an AI coding agent processing a prompt against a repository
 */
export type AgentRun = {
    /**
     * The git branch the agent is operating on (uses default branch if not set)
     */
    branch?: string;
    /**
     * Error message if the agent run failed
     */
    error?: string;
    /**
     * ID of the flow this agent run is associated with, if any
     */
    flow_id?: string;
    /**
     * Unique identifier for the agent run
     */
    id?: string;
    inserted_at?: string;
    /**
     * Programming language used in the agent run (javascript, python, java, cpp, csharp, go, ruby, php, terraform)
     */
    language?: 'javascript' | 'python' | 'java' | 'cpp' | 'csharp' | 'go' | 'ruby' | 'php' | 'terraform';
    /**
     * Specific version of the programming language to use
     */
    language_version?: string;
    /**
     * Mode of the agent run (analyze for read-only analysis, write for code modifications)
     */
    mode?: 'analyze' | 'write';
    /**
     * The prompt given to the AI agent to process
     */
    prompt?: string;
    /**
     * The git repository URL the agent is working on
     */
    repository?: string;
    /**
     * ID of the runtime executing this agent run
     */
    runtime_id?: string;
    /**
     * Whether this agent run is shared publicly
     */
    shared?: boolean;
    /**
     * Current status of the agent run (pending, running, successful, failed, cancelled)
     */
    status?: 'pending' | 'running' | 'successful' | 'failed' | 'cancelled';
    updated_at?: string;
    /**
     * ID of the user who initiated this agent run
     */
    user_id?: string;
};

/**
 * AgentRunInput
 *
 * Input for creating a new agent run to execute an AI coding agent
 */
export type AgentRunInput = {
    /**
     * Optional flow ID to associate this agent run with
     */
    flow_id?: string;
    /**
     * Mode of the agent run (analyze for read-only, write for modifications)
     */
    mode: 'analyze' | 'write';
    /**
     * The prompt to give to the agent describing the task to perform
     */
    prompt: string;
    /**
     * The git repository URL the agent will work on (https or ssh format)
     */
    repository: string;
    /**
     * The runtime ID to execute the agent run on
     */
    runtime_id: string;
    /**
     * Whether to share this agent run publicly
     */
    shared?: boolean;
};

/**
 * AgentRuntime
 *
 * An agent runtime configured on a cluster for executing AI coding agents
 */
export type AgentRuntime = {
    /**
     * Whether this runtime uses the built-in Plural AI proxy for LLM requests
     */
    ai_proxy?: boolean;
    /**
     * The git repositories allowed to be used with this runtime
     */
    allowed_repositories?: Array<string>;
    /**
     * ID of the cluster this runtime is deployed on
     */
    cluster_id?: string;
    /**
     * Whether this is the default runtime for coding agents
     */
    default?: boolean;
    /**
     * Unique identifier for the agent runtime
     */
    id?: string;
    inserted_at?: string;
    /**
     * Human-readable name of this runtime
     */
    name?: string;
    /**
     * Type of agent runtime (claude, opencode, gemini, custom)
     */
    type?: 'claude' | 'opencode' | 'gemini' | 'custom' | 'codex';
    updated_at?: string;
};

/**
 * AgentSession
 *
 * An autonomous AI agent session working on infrastructure tasks
 */
export type AgentSession = {
    /**
     * Internal agent identifier
     */
    agent_id?: string;
    /**
     * The git branch this session's pull request is operating on
     */
    branch?: string;
    /**
     * ID of the cluster associated with this session
     */
    cluster_id?: string;
    /**
     * Number of commits made by this agent session
     */
    commit_count?: number;
    /**
     * ID of the cloud connection used by this session
     */
    connection_id?: string;
    /**
     * Whether the agent has declared the work for this session complete
     */
    done?: boolean;
    /**
     * Unique identifier for the agent session
     */
    id?: string;
    /**
     * Whether the agent session has been initialized
     */
    initialized?: boolean;
    inserted_at?: string;
    /**
     * Whether the provisioning plan has been confirmed by the user
     */
    plan_confirmed?: boolean;
    /**
     * The prompt given to the agent
     */
    prompt?: string;
    /**
     * ID of the pull request created by this session
     */
    pull_request_id?: string;
    /**
     * ID of the service associated with this session
     */
    service_id?: string;
    /**
     * ID of the infrastructure stack associated with this session
     */
    stack_id?: string;
    /**
     * ID of the chat thread associated with this session
     */
    thread_id?: string;
    /**
     * Type of agent session (terraform, kubernetes, provisioning, search, manifests, chat, research)
     */
    type?: 'terraform' | 'kubernetes' | 'provisioning' | 'search' | 'manifests' | 'chat' | 'research';
    updated_at?: string;
};

/**
 * AgentSessionInput
 *
 * Input for creating a new agent session to execute autonomous infrastructure tasks
 */
export type AgentSessionInput = {
    /**
     * ID of the cluster to use for this session
     */
    cluster_id?: string;
    /**
     * ID of the cloud connection to use for this session
     */
    connection_id?: string;
    /**
     * Whether to immediately mark this session as done
     */
    done?: boolean;
    /**
     * Whether the provisioning plan is pre-confirmed
     */
    plan_confirmed?: boolean;
    /**
     * The prompt describing the task for the agent to perform
     */
    prompt: string;
    /**
     * Type of agent session (terraform, kubernetes)
     */
    type?: 'terraform' | 'kubernetes';
};

/**
 * Cascade
 *
 * Cascade behavior when the global service is deleted
 */
export type Cascade = {
    /**
     * If true, cascade delete all services owned by this global service
     */
    delete?: boolean;
    /**
     * If true, immediately detach services from the database without draining
     */
    detach?: boolean;
};

/**
 * CascadeInput
 *
 * Input for cascade behavior when the global service is deleted
 */
export type CascadeInput = {
    /**
     * If true, cascade delete all services owned by this global service
     */
    delete?: boolean;
    /**
     * If true, immediately detach services from the database without draining
     */
    detach?: boolean;
};

/**
 * Catalog
 *
 * A catalog of PR automations for self-service deployment workflows
 */
export type Catalog = {
    /**
     * Author or maintainer of the catalog
     */
    author?: string;
    /**
     * Category for organizing catalogs (e.g., infrastructure, applications)
     */
    category?: string;
    /**
     * URL or reference to the catalog's icon for dark mode
     */
    dark_icon?: string;
    /**
     * Description of the catalog's purpose and contents
     */
    description?: string;
    /**
     * URL or reference to the catalog's icon for light mode
     */
    icon?: string;
    /**
     * Unique identifier for the catalog
     */
    id?: string;
    inserted_at?: string;
    /**
     * Name of the catalog
     */
    name?: string;
    /**
     * ID of the project this catalog belongs to
     */
    project_id?: string;
    updated_at?: string;
};

/**
 * CatalogInput
 *
 * Input for creating or updating a catalog
 */
export type CatalogInput = {
    /**
     * Author or maintainer of the catalog
     */
    author: string;
    /**
     * Category for organizing the catalog
     */
    category?: string;
    /**
     * URL or reference to the catalog's icon for dark mode
     */
    dark_icon?: string;
    /**
     * Description of the catalog's purpose
     */
    description?: string;
    /**
     * URL or reference to the catalog's icon for light mode
     */
    icon?: string;
    /**
     * Name for the catalog
     */
    name: string;
    /**
     * ID of the project this catalog belongs to
     */
    project_id?: string;
};

/**
 * Cluster
 *
 * A Kubernetes cluster that can be deployed to and managed through the platform
 */
export type Cluster = {
    /**
     * Key/value tags to filter and organize clusters
     */
    tags?: Array<Tag>;
    /**
     * The availability zones this cluster is running in
     */
    availability_zones?: Array<string>;
    /**
     * The total CPU capacity of the cluster in cores
     */
    cpu_total?: number;
    /**
     * The current CPU utilization of the cluster as a percentage
     */
    cpu_util?: number;
    /**
     * Current Kubernetes version as reported by the deployment operator
     */
    current_version?: string;
    /**
     * Timestamp when this cluster was scheduled for deletion
     */
    deleted_at?: string;
    /**
     * The distribution of kubernetes this cluster is running (generic, eks, aks, gke, rke, k3s, openshift)
     */
    distro?: 'generic' | 'eks' | 'aks' | 'gke' | 'rke' | 'k3s' | 'openshift';
    /**
     * A short, unique human readable name used to identify this cluster
     */
    handle?: string;
    /**
     * Unique identifier for the cluster
     */
    id?: string;
    inserted_at?: string;
    /**
     * Whether the deploy operator has been registered for this cluster
     */
    installed?: boolean;
    /**
     * The lowest discovered kubelet version for all nodes in the cluster
     */
    kubelet_version?: string;
    /**
     * The total memory capacity of the cluster in bytes
     */
    memory_total?: number;
    /**
     * The current memory utilization of the cluster as a percentage
     */
    memory_util?: number;
    /**
     * Arbitrary JSON metadata to store user-specific state of this cluster
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Human readable name of this cluster, will also translate to cloud k8s name
     */
    name?: string;
    /**
     * The number of namespaces in this cluster
     */
    namespace_count?: number;
    /**
     * The number of nodes in this cluster
     */
    node_count?: number;
    /**
     * The version of OpenShift this cluster is running, if applicable
     */
    openshift_version?: string;
    /**
     * Timestamp of the last ping from the deploy operator
     */
    pinged_at?: string;
    /**
     * The number of pods in this cluster
     */
    pod_count?: number;
    /**
     * ID of the project this cluster belongs to
     */
    project_id?: string;
    /**
     * If true, this cluster cannot be deleted
     */
    protect?: boolean;
    /**
     * Whether this is the management cluster itself
     */
    self?: boolean;
    updated_at?: string;
    /**
     * Desired Kubernetes version for the cluster
     */
    version?: string;
    /**
     * Whether this is a virtual cluster
     */
    virtual?: boolean;
};

/**
 * ClusterInput
 *
 * Input for creating or updating a cluster
 */
export type ClusterInput = {
    /**
     * Key/value tags to filter and organize clusters
     */
    tags?: Array<TagInput>;
    /**
     * A short, unique human readable name used to identify this cluster
     */
    handle?: string;
    /**
     * Arbitrary JSON metadata to store user-specific state
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Human readable name for the cluster
     */
    name?: string;
    /**
     * ID of the project this cluster belongs to
     */
    project_id?: string;
};

/**
 * ClusterUpgrade
 *
 * An agentic workflow for upgrading a cluster
 */
export type ClusterUpgrade = {
    /**
     * ID of the cluster being upgraded
     */
    cluster_id?: string;
    /**
     * Unique identifier for the cluster upgrade
     */
    id?: string;
    inserted_at?: string;
    /**
     * Prompt used to generate the upgrade workflow
     */
    prompt?: string;
    runtime?: AgentRuntime;
    /**
     * ID of the agent runtime executing the upgrade
     */
    runtime_id?: string;
    /**
     * Status of the upgrade (pending, in_progress, completed, failed)
     */
    status?: 'pending' | 'in_progress' | 'completed' | 'failed';
    /**
     * Steps that make up this upgrade workflow
     */
    steps?: Array<ClusterUpgradeStep>;
    updated_at?: string;
    user?: User;
    /**
     * ID of the user who initiated the upgrade
     */
    user_id?: string;
    /**
     * Target Kubernetes version for this upgrade
     */
    version?: string;
};

/**
 * ClusterUpgradeInput
 *
 * Input for creating a cluster upgrade workflow
 */
export type ClusterUpgradeInput = {
    /**
     * Optional prompt to guide the upgrade workflow
     */
    prompt?: string;
    /**
     * Optional agent runtime ID to execute the upgrade
     */
    runtime_id?: string;
};

/**
 * ClusterUpgradeStep
 *
 * A step in an agentic cluster upgrade workflow
 */
export type ClusterUpgradeStep = {
    agent_run?: AgentRun;
    /**
     * ID of the agent run associated with this step, if any
     */
    agent_run_id?: string;
    /**
     * Error message if the step failed
     */
    error?: string;
    /**
     * Unique identifier for the upgrade step
     */
    id?: string;
    inserted_at?: string;
    /**
     * Name of the upgrade step
     */
    name?: string;
    /**
     * Prompt used to generate the upgrade step
     */
    prompt?: string;
    /**
     * Status of the step (pending, in_progress, completed, failed)
     */
    status?: 'pending' | 'in_progress' | 'completed' | 'failed';
    /**
     * Type of step (addon, cloud_addon, infrastructure)
     */
    type?: 'addon' | 'cloud_addon' | 'infrastructure';
    updated_at?: string;
    /**
     * ID of the cluster upgrade this step belongs to
     */
    upgrade_id?: string;
};

/**
 * A paginated list of agent runs
 */
export type ConsoleOpenApiAiAgentRunList = {
    data?: Array<AgentRun>;
};

/**
 * A paginated list of agent runtimes
 */
export type ConsoleOpenApiAiAgentRuntimeList = {
    data?: Array<AgentRuntime>;
};

/**
 * A paginated list of agent sessions
 */
export type ConsoleOpenApiAiAgentSessionList = {
    data?: Array<AgentSession>;
};

/**
 * A paginated list of sentinels
 */
export type ConsoleOpenApiAiSentinelList = {
    data?: Array<Sentinel>;
};

/**
 * A paginated list of sentinel runs
 */
export type ConsoleOpenApiAiSentinelRunList = {
    data?: Array<SentinelRun>;
};

/**
 * A scope entry for an access token
 */
export type ConsoleOpenApiAccessTokenScope = {
    /**
     * A single API name
     */
    api?: string;
    /**
     * API name
     */
    apis?: Array<string>;
    /**
     * Identifier for scoped access
     */
    identifier?: string;
    /**
     * Scoped resource ids
     */
    ids?: Array<string>;
};

/**
 * A paginated list of clusters
 */
export type ConsoleOpenApiCdClusterList = {
    data?: Array<Cluster>;
};

/**
 * A list of git repositories
 */
export type ConsoleOpenApiCdGitRepositoryList = {
    data?: Array<GitRepository>;
};

/**
 * A paginated list of global services
 */
export type ConsoleOpenApiCdGlobalServiceList = {
    data?: Array<GlobalService>;
};

/**
 * A list of helm repositories
 */
export type ConsoleOpenApiCdHelmRepositoryList = {
    data?: Array<HelmRepository>;
};

/**
 * A paginated list of pipelines
 */
export type ConsoleOpenApiCdPipelineList = {
    data?: Array<Pipeline>;
};

/**
 * A paginated list of service deployments
 */
export type ConsoleOpenApiCdServiceList = {
    data?: Array<Service>;
};

/**
 * A paginated list of projects
 */
export type ConsoleOpenApiProjectList = {
    data?: Array<Project>;
};

/**
 * A paginated list of catalogs
 */
export type ConsoleOpenApiScmCatalogList = {
    data?: Array<Catalog>;
};

/**
 * A Github App connection
 */
export type ConsoleOpenApiScmConnectionGithubApp = {
    /**
     * The Github App ID
     */
    app_id?: string;
    /**
     * The Github App installation ID
     */
    installation_id?: string;
};

/**
 * A list of SCM connections
 */
export type ConsoleOpenApiScmConnectionList = {
    data?: Array<ScmConnection>;
};

/**
 * A paginated list of PR automations
 */
export type ConsoleOpenApiScmPrAutomationList = {
    data?: Array<PrAutomation>;
};

/**
 * A paginated list of pull requests
 */
export type ConsoleOpenApiScmPullRequestList = {
    data?: Array<PullRequest>;
};

/**
 * A list of stacks
 */
export type ConsoleOpenApiStackList = {
    data?: Array<Stack>;
};

/**
 * A list of users
 */
export type ConsoleOpenApiUserList = {
    data?: Array<User>;
};

/**
 * The roles of the user
 */
export type ConsoleOpenApiUserRoles = {
    admin: boolean;
};

/**
 * CreatePullRequestInput
 *
 * Input for creating a pull request using a PR automation
 */
export type CreatePullRequestInput = {
    /**
     * Branch name for the pull request (overrides default)
     */
    branch?: string;
    /**
     * Context variables to pass to the PR automation templates
     */
    context: {
        [key: string]: unknown;
    };
    /**
     * Repository identifier (overrides default)
     */
    identifier?: string;
};

/**
 * Git
 *
 * Git reference configuration
 */
export type Git = {
    folder?: string;
    ref?: string;
};

/**
 * GitRepository
 *
 * A git repository
 */
export type GitRepository = {
    auth_method?: 'basic' | 'ssh';
    /**
     * The error message for the git repository's last pull attempt
     */
    error?: string;
    health?: 'pullable' | 'failed';
    /**
     * The https url for this git repo if you need to customize it
     */
    https_path?: string;
    id?: string;
    inserted_at?: string;
    /**
     * The last successful git pull timestamp
     */
    pulled_at?: string;
    updated_at?: string;
    /**
     * The url of the git repository, can be either an https or ssh url
     */
    url?: string;
    /**
     * A format string to get the http url for a subfolder in a git repo
     */
    url_format?: string;
};

/**
 * GitRepositoryInput
 *
 * Input for creating or updating a git repository
 */
export type GitRepositoryInput = {
    /**
     * The id of the scm connection to use for authentication
     */
    connection_id?: string;
    /**
     * A passphrase to decrypt the given private key
     */
    passphrase?: string;
    /**
     * The http password for http authenticated repos
     */
    password?: string;
    /**
     * An ssh private key to use with this repo if an ssh url was given
     */
    private_key?: string;
    /**
     * The url of the git repository, can be either an https or ssh url
     */
    url: string;
    /**
     * The http username for authenticated http repos, defaults to apiKey for github
     */
    username?: string;
};

/**
 * GithubAppInput
 *
 * Github App authentication configuration
 */
export type GithubAppInput = {
    /**
     * The GitHub App ID
     */
    app_id: string;
    /**
     * The GitHub App installation ID
     */
    installation_id: string;
    /**
     * The private key for the GitHub App
     */
    private_key: string;
};

/**
 * GlobalService
 *
 * A global service that deploys services across clusters matching specified criteria
 */
export type GlobalService = {
    /**
     * Tags used to match target clusters
     */
    tags?: Array<Tag>;
    cascade?: Cascade;
    /**
     * Target cluster distribution (e.g., eks, aks, gke, generic)
     */
    distro?: 'generic' | 'eks' | 'aks' | 'gke' | 'rke' | 'k3s' | 'openshift';
    /**
     * Unique identifier for the global service
     */
    id?: string;
    inserted_at?: string;
    /**
     * Polling interval for syncing the global service (e.g., "5m", "1h")
     */
    interval?: string;
    /**
     * If true, the global service will target the management cluster
     */
    mgmt?: boolean;
    /**
     * Name of the global service
     */
    name?: string;
    /**
     * ID of the project this global service belongs to
     */
    project_id?: string;
    /**
     * ID of the cluster provider to filter target clusters
     */
    provider_id?: string;
    /**
     * If true, allows reparenting of existing services owned by this global service
     */
    reparent?: boolean;
    /**
     * ID of the source service to clone (mutually exclusive with template)
     */
    service_id?: string;
    template?: ServiceTemplate;
    updated_at?: string;
};

/**
 * GlobalServiceInput
 *
 * Input for creating or updating a global service
 */
export type GlobalServiceInput = {
    /**
     * Tags used to match target clusters
     */
    tags?: Array<TagInput>;
    cascade?: CascadeInput;
    /**
     * Target cluster distribution
     */
    distro?: 'generic' | 'eks' | 'aks' | 'gke' | 'rke' | 'k3s' | 'openshift';
    /**
     * Polling interval for syncing (e.g., "5m", "1h")
     */
    interval?: string;
    /**
     * If true, target the management cluster
     */
    mgmt?: boolean;
    /**
     * Name for the global service
     */
    name: string;
    /**
     * ID of the project this global service belongs to
     */
    project_id?: string;
    /**
     * ID of the cluster provider to filter target clusters
     */
    provider_id?: string;
    /**
     * If true, allows reparenting of existing services
     */
    reparent?: boolean;
    template?: ServiceTemplateInput;
};

/**
 * HelmRepository
 *
 * A helm repository
 */
export type HelmRepository = {
    /**
     * The error message for the helm repository's last pull attempt
     */
    error?: string;
    health?: 'pullable' | 'failed';
    id?: string;
    inserted_at?: string;
    provider?: 'basic' | 'bearer' | 'gcp' | 'azure' | 'aws';
    /**
     * The last successful pull timestamp
     */
    pulled_at?: string;
    updated_at?: string;
    /**
     * The url of the helm repository
     */
    url?: string;
};

/**
 * HelmRepositoryInput
 *
 * Input for upserting a helm repository
 */
export type HelmRepositoryInput = {
    /**
     * Authentication configuration for the helm repository
     */
    auth?: {
        /**
         * AWS credentials for ECR
         */
        aws?: {
            /**
             * AWS access key ID
             */
            access_key?: string;
            /**
             * ARN of the role to assume
             */
            assume_role_arn?: string;
            /**
             * AWS secret access key
             */
            secret_access_key?: string;
        };
        /**
         * Azure credentials for ACR
         */
        azure?: {
            /**
             * Azure client ID
             */
            client_id?: string;
            /**
             * Azure client secret
             */
            client_secret?: string;
            /**
             * Azure subscription ID
             */
            subscription_id?: string;
            /**
             * Azure tenant ID
             */
            tenant_id?: string;
        };
        /**
         * Basic auth credentials
         */
        basic?: {
            /**
             * The password for basic auth
             */
            password?: string;
            /**
             * The username for basic auth
             */
            username?: string;
        };
        /**
         * Bearer token auth
         */
        bearer?: {
            /**
             * The bearer token
             */
            token?: string;
        };
        /**
         * GCP credentials for GCR/Artifact Registry
         */
        gcp?: {
            /**
             * GCP service account JSON credentials
             */
            application_credentials?: string;
        };
    };
    provider?: 'basic' | 'bearer' | 'gcp' | 'azure' | 'aws';
    /**
     * The url of the helm repository
     */
    url?: string;
};

/**
 * HelmSpec
 *
 * Helm chart configuration for a service
 */
export type HelmSpec = {
    /**
     * Helm chart name (e.g., "nginx")
     */
    chart?: string;
    /**
     * Helm release name for the deployment
     */
    release?: string;
    /**
     * ID of the Helm repository for this chart
     */
    repository_id?: string;
    /**
     * URL of the Helm chart repository
     */
    url?: string;
    /**
     * Inline helm values for the helm chart
     */
    values?: string;
    /**
     * List of referenced values.yaml files
     */
    values_files?: Array<string>;
    /**
     * Helm chart version
     */
    version?: string;
};

/**
 * HelmSpecInput
 *
 * Helm chart configuration input
 */
export type HelmSpecInput = {
    /**
     * Name of the Helm chart to deploy
     */
    chart?: string;
    /**
     * Desired Helm release name
     */
    release?: string;
    /**
     * ID of a GitRepository to use for sourcing this helm chart
     */
    repository_id?: string;
    /**
     * Helm chart repository URL
     */
    url?: string;
    /**
     * YAML configuration values for the Helm chart
     */
    values?: string;
    /**
     * List of referenced values.yaml files to be used with the chart
     */
    values_files?: Array<string>;
    /**
     * Version of the Helm chart
     */
    version?: string;
};

/**
 * Kustomize
 *
 * Kustomize configuration for a service
 */
export type Kustomize = {
    /**
     * If true, Helm integration is enabled for Kustomize
     */
    enable_helm?: boolean;
    /**
     * Path to the kustomization.yaml or kustomize directory relative to the repository root
     */
    path?: string;
};

/**
 * KustomizeInput
 *
 * Kustomize configuration input
 */
export type KustomizeInput = {
    /**
     * Enable Helm support within Kustomize if true
     */
    enable_helm?: boolean;
    /**
     * Path to the kustomization.yaml or kustomize directory
     */
    path?: string;
};

/**
 * Pipeline
 *
 * A continuous deployment pipeline that orchestrates service promotions through stages
 */
export type Pipeline = {
    /**
     * Edges connecting stages with promotion gates
     */
    edges?: Array<PipelineEdge>;
    /**
     * Unique identifier for the pipeline
     */
    id?: string;
    inserted_at?: string;
    /**
     * Name of the pipeline
     */
    name?: string;
    /**
     * ID of the project this pipeline belongs to
     */
    project_id?: string;
    /**
     * Ordered list of stages in this pipeline
     */
    stages?: Array<PipelineStage>;
    updated_at?: string;
};

/**
 * PipelineContext
 *
 * A context containing data for pipeline promotions and PR automations
 */
export type PipelineContext = {
    /**
     * Arbitrary key-value data map passed through the pipeline
     */
    context?: {
        [key: string]: unknown;
    };
    /**
     * Unique identifier for the context
     */
    id?: string;
    inserted_at?: string;
    /**
     * ID of the pipeline this context belongs to
     */
    pipeline_id?: string;
    updated_at?: string;
};

/**
 * PipelineContextInput
 *
 * Input for creating a new pipeline context to trigger a pipeline run
 */
export type PipelineContextInput = {
    /**
     * Arbitrary key-value data map to pass through the pipeline for PR automations
     */
    context: {
        [key: string]: unknown;
    };
};

/**
 * PipelineEdge
 *
 * An edge connecting two stages with optional promotion gates
 */
export type PipelineEdge = {
    /**
     * ID of the source stage
     */
    from_id?: string;
    /**
     * Gates that must be satisfied for promotion
     */
    gates?: Array<PipelineGate>;
    /**
     * Unique identifier for the edge
     */
    id?: string;
    inserted_at?: string;
    /**
     * Timestamp when promotion last occurred through this edge
     */
    promoted_at?: string;
    /**
     * ID of the destination stage
     */
    to_id?: string;
    updated_at?: string;
};

/**
 * PipelineGate
 *
 * A gate checkpoint for pipeline promotions
 */
export type PipelineGate = {
    /**
     * Unique identifier for the gate
     */
    id?: string;
    inserted_at?: string;
    /**
     * Name of the gate
     */
    name?: string;
    /**
     * Current state of the gate (pending, open, closed, running)
     */
    state?: 'pending' | 'open' | 'closed' | 'running';
    /**
     * Type of gate (approval, window, job)
     */
    type?: 'approval' | 'window' | 'job' | 'sentinel';
    updated_at?: string;
};

/**
 * PipelineStage
 *
 * A stage in the pipeline representing a deployment environment
 */
export type PipelineStage = {
    /**
     * Unique identifier for the stage
     */
    id?: string;
    inserted_at?: string;
    /**
     * Name of the stage (e.g., dev, staging, production)
     */
    name?: string;
    /**
     * Services deployed in this stage
     */
    services?: Array<StageService>;
    updated_at?: string;
};

/**
 * PrAutomation
 *
 * A PR automation template for creating infrastructure or application pull requests
 */
export type PrAutomation = {
    /**
     * Title template for generated pull requests
     */
    title?: string;
    /**
     * Name of the addon this PR automation is associated with, if any
     */
    addon?: string;
    /**
     * Default branch name for generated pull requests
     */
    branch?: string;
    /**
     * ID of the catalog this PR automation belongs to
     */
    catalog_id?: string;
    /**
     * ID of the cluster this PR automation is associated with, if any
     */
    cluster_id?: string;
    /**
     * Configuration fields for the PR automation
     */
    configuration?: Array<PrConfiguration>;
    /**
     * ID of the SCM connection used for creating pull requests
     */
    connection_id?: string;
    /**
     * URL or reference to the PR automation's icon for dark mode
     */
    dark_icon?: string;
    /**
     * Documentation describing the PR automation's purpose and usage
     */
    documentation?: string;
    /**
     * URL or reference to the PR automation's icon for light mode
     */
    icon?: string;
    /**
     * Unique identifier for the PR automation
     */
    id?: string;
    /**
     * Repository identifier (e.g., owner/repo) for the PR automation
     */
    identifier?: string;
    inserted_at?: string;
    /**
     * Message/body template for generated pull requests
     */
    message?: string;
    /**
     * Name of the PR automation
     */
    name?: string;
    /**
     * ID of the project this PR automation belongs to
     */
    project_id?: string;
    /**
     * ID of the service this PR automation is associated with, if any
     */
    service_id?: string;
    updated_at?: string;
};

/**
 * PrConfiguration
 *
 * A configuration field for a PR automation
 */
export type PrConfiguration = {
    /**
     * Default value for the configuration field
     */
    default?: string;
    /**
     * Documentation describing the configuration field
     */
    documentation?: string;
    /**
     * Extended documentation for the configuration field
     */
    longform?: string;
    /**
     * Name of the configuration field
     */
    name?: string;
    /**
     * Whether the configuration field is optional
     */
    optional?: boolean;
    /**
     * Placeholder text for the configuration field input
     */
    placeholder?: string;
    /**
     * Type of the configuration field (string, int, bool, domain, file, function, enum, password)
     */
    type?: 'string' | 'int' | 'bool' | 'domain' | 'bucket' | 'file' | 'function' | 'password' | 'enum' | 'cluster' | 'project' | 'group' | 'user' | 'flow' | 'json';
    validation?: PrConfigurationValidation;
};

/**
 * PrConfigurationValidation
 *
 * Validation rules for a configuration field
 */
export type PrConfigurationValidation = {
    /**
     * Error message to display when validation fails
     */
    message?: string;
    /**
     * Regular expression pattern for validation
     */
    regex?: string;
};

/**
 * Project
 *
 * A project is a top-level organizational unit that groups related resources such as clusters, stacks, pipelines, and services
 */
export type Project = {
    /**
     * Whether this is the default project for the instance
     */
    default?: boolean;
    /**
     * A human-readable description of the project
     */
    description?: string;
    /**
     * The unique identifier of the project
     */
    id?: string;
    inserted_at?: string;
    /**
     * The name of the project
     */
    name?: string;
    updated_at?: string;
};

/**
 * PromotionCriteria
 *
 * Criteria for promoting a service to the next stage
 */
export type PromotionCriteria = {
    /**
     * Unique identifier for the promotion criteria
     */
    id?: string;
    inserted_at?: string;
    /**
     * ID of the PR automation to trigger on promotion
     */
    pr_automation_id?: string;
    /**
     * Repository to create PRs against for promotion
     */
    repository?: string;
    updated_at?: string;
};

/**
 * PullRequest
 *
 * A pull request reference tracked by the platform for deployment workflows
 */
export type PullRequest = {
    /**
     * Title of the pull request
     */
    title?: string;
    /**
     * Body/description of the pull request
     */
    body?: string;
    /**
     * ID of the cluster this pull request is associated with, if any
     */
    cluster_id?: string;
    /**
     * Username of the pull request creator in the source control provider
     */
    creator?: string;
    /**
     * Unique identifier for the pull request record
     */
    id?: string;
    inserted_at?: string;
    /**
     * Labels applied to the pull request
     */
    labels?: Array<string>;
    /**
     * Git ref (branch name) for the pull request
     */
    ref?: string;
    /**
     * ID of the service this pull request is associated with, if any
     */
    service_id?: string;
    /**
     * Git SHA of the pull request head
     */
    sha?: string;
    /**
     * ID of the stack this pull request is associated with, if any
     */
    stack_id?: string;
    /**
     * Current status of the pull request (open, merged, closed)
     */
    status?: 'open' | 'merged' | 'closed';
    updated_at?: string;
    /**
     * URL of the pull request in the source control provider
     */
    url?: string;
};

/**
 * RendererHelm
 *
 * Helm-specific configuration for a renderer
 */
export type RendererHelm = {
    /**
     * Whether to ignore Helm hooks when rendering
     */
    ignore_hooks?: boolean;
    /**
     * Helm release name to use when rendering
     */
    release?: string;
    /**
     * Helm values file content to use when rendering
     */
    values?: string;
    /**
     * List of relative paths to values files
     */
    values_files?: Array<string>;
};

/**
 * RendererHelmInput
 *
 * Helm-specific configuration input for a renderer
 */
export type RendererHelmInput = {
    /**
     * Whether to ignore Helm hooks when rendering
     */
    ignore_hooks?: boolean;
    /**
     * Helm release name to use when rendering
     */
    release?: string;
    /**
     * Helm values file content to use when rendering
     */
    values?: string;
    /**
     * List of relative paths to values files
     */
    values_files?: Array<string>;
};

/**
 * ScmConnection
 *
 * An SCM connection for integrating with source control providers
 */
export type ScmConnection = {
    /**
     * Base URL for HTTP APIs for self-hosted versions if different from base URL
     */
    api_url?: string;
    /**
     * Base URL for self-hosted versions of this provider
     */
    base_url?: string;
    /**
     * Whether this is the default SCM connection
     */
    default?: boolean;
    github?: ConsoleOpenApiScmConnectionGithubApp;
    id?: string;
    inserted_at?: string;
    /**
     * The name of the SCM connection
     */
    name: string;
    type: 'github' | 'gitlab' | 'bitbucket' | 'azure_devops' | 'bitbucket_datacenter';
    updated_at?: string;
    /**
     * The username for authentication
     */
    username?: string;
};

/**
 * ScmConnectionInput
 *
 * Input for creating or updating an SCM connection
 */
export type ScmConnectionInput = {
    /**
     * Base URL for HTTP APIs for self-hosted versions if different from base URL
     */
    api_url?: string;
    /**
     * Base URL for Git clones for self-hosted versions
     */
    base_url?: string;
    /**
     * Whether this is the default SCM connection
     */
    default?: boolean;
    github?: GithubAppInput;
    /**
     * The name of the SCM connection
     */
    name: string;
    /**
     * A private key used for signing commits
     */
    signing_private_key?: string;
    /**
     * The access token for authentication
     */
    token?: string;
    type: 'github' | 'gitlab' | 'bitbucket' | 'azure_devops' | 'bitbucket_datacenter';
    /**
     * The username for authentication
     */
    username?: string;
};

/**
 * Sentinel
 *
 * An automated monitoring system that runs checks against your infrastructure
 */
export type Sentinel = {
    /**
     * List of checks configured for this sentinel
     */
    checks?: Array<SentinelCheck>;
    /**
     * Description of what this sentinel monitors
     */
    description?: string;
    /**
     * Unique identifier for the sentinel
     */
    id?: string;
    inserted_at?: string;
    /**
     * Timestamp of when this sentinel was last executed
     */
    last_run_at?: string;
    /**
     * Human-readable name of this sentinel
     */
    name?: string;
    /**
     * ID of the project this sentinel belongs to
     */
    project_id?: string;
    /**
     * ID of the git repository for rule files
     */
    repository_id?: string;
    /**
     * Status of the sentinel's last run (pending, success, failed)
     */
    status?: 'pending' | 'success' | 'failed';
    updated_at?: string;
};

/**
 * SentinelCheck
 *
 * A specific monitoring check within a sentinel
 */
export type SentinelCheck = {
    /**
     * Unique identifier for the check
     */
    id?: string;
    /**
     * Name of this check
     */
    name?: string;
    /**
     * Path to the rule file for this check within the repository
     */
    rule_file?: string;
    /**
     * Type of check (log, kubernetes, integration_test)
     */
    type?: 'log' | 'kubernetes' | 'integration_test';
};

/**
 * SentinelCheckResult
 *
 * The result of a single check within a sentinel run
 */
export type SentinelCheckResult = {
    /**
     * Number of failed jobs
     */
    failed_count?: number;
    /**
     * Total number of jobs spawned for this check
     */
    job_count?: number;
    /**
     * Name of the check that was executed
     */
    name?: string;
    /**
     * Reason for failure if the check failed
     */
    reason?: string;
    /**
     * Status of this check (pending, success, failed)
     */
    status?: 'pending' | 'success' | 'failed';
    /**
     * Number of successful jobs
     */
    successful_count?: number;
};

/**
 * SentinelRun
 *
 * A single execution of a sentinel's monitoring checks
 */
export type SentinelRun = {
    /**
     * Timestamp when the run completed
     */
    completed_at?: string;
    /**
     * Unique identifier for the sentinel run
     */
    id?: string;
    inserted_at?: string;
    /**
     * Jobs spawned by this sentinel run for integration tests
     */
    jobs?: Array<SentinelRunJob>;
    /**
     * Results of individual checks in this run
     */
    results?: Array<SentinelCheckResult>;
    /**
     * ID of the sentinel that was executed
     */
    sentinel_id?: string;
    /**
     * Current status of the run (pending, success, failed)
     */
    status?: 'pending' | 'success' | 'failed';
    updated_at?: string;
};

/**
 * SentinelRunJob
 *
 * An integration test job spawned by a sentinel run
 */
export type SentinelRunJob = {
    /**
     * Name of the check this job belongs to
     */
    check?: string;
    /**
     * ID of the cluster this job ran on
     */
    cluster_id?: string;
    /**
     * Timestamp when the job completed
     */
    completed_at?: string;
    /**
     * Output format of the job (plaintext, junit)
     */
    format?: 'plaintext' | 'junit';
    /**
     * Unique identifier for the job
     */
    id?: string;
    inserted_at?: string;
    /**
     * Output produced by the job
     */
    output?: string;
    /**
     * ID of the git repository used for the test
     */
    repository_id?: string;
    /**
     * ID of the sentinel run this job belongs to
     */
    sentinel_run_id?: string;
    /**
     * Current status of the job (pending, running, success, failed)
     */
    status?: 'pending' | 'running' | 'success' | 'failed';
    updated_at?: string;
};

/**
 * Service
 *
 * A service deployment reference deployed from a git repo into a cluster
 */
export type Service = {
    /**
     * ID of the cluster this service is deployed to
     */
    cluster_id?: string;
    /**
     * Status message from components (e.g. unhealthy reason)
     */
    component_status?: string;
    /**
     * Timestamp the service was marked for deletion, if deleted
     */
    deleted_at?: string;
    /**
     * If true, this service is running in dry-run mode
     */
    dry_run?: boolean;
    /**
     * List of errors generated by the deployment operator
     */
    errors?: Array<ServiceError>;
    git?: Git;
    helm?: HelmSpec;
    /**
     * Unique identifier for the service deployment
     */
    id?: string;
    inserted_at?: string;
    /**
     * Polling interval for the service reconcile loop (e.g., "5m")
     */
    interval?: string;
    kustomize?: Kustomize;
    /**
     * Latest commit message from the synced revision
     */
    message?: string;
    /**
     * Name of the service
     */
    name?: string;
    /**
     * Kubernetes namespace where the service is deployed
     */
    namespace?: string;
    /**
     * If true, prevents service deletion or config edits
     */
    protect?: boolean;
    /**
     * Custom renderers for processing service manifests
     */
    renderers?: Array<ServiceRenderer>;
    /**
     * ID of the git or Helm repository backing this service
     */
    repository_id?: string;
    /**
     * Git commit SHA for the current synced revision.  This will be a helm digest if a pure helm chart as well
     */
    sha?: string;
    /**
     * Additional source repositories for this service
     */
    sources?: Array<ServiceSource>;
    /**
     * Current status of the service deployment (e.g., stale, synced, healthy, failed, paused)
     */
    status?: 'stale' | 'synced' | 'healthy' | 'failed' | 'paused';
    /**
     * If true, the service was deployed using a template
     */
    templated?: boolean;
    updated_at?: string;
};

/**
 * ServiceConfigurationInput
 *
 * A configuration key-value pair for a service deployment. These are used as templating values when rendering service manifests.
 */
export type ServiceConfigurationInput = {
    /**
     * The name/key of the configuration value
     */
    name: string;
    /**
     * The value for this configuration key. If null, will remove this value
     */
    value?: string;
};

/**
 * ServiceError
 *
 * An error reported by the deployment operator during service sync
 */
export type ServiceError = {
    /**
     * Error message describing what went wrong
     */
    message?: string;
    /**
     * Source of the error (e.g., component name or sync stage)
     */
    source?: string;
    /**
     * If true, this is a warning rather than a fatal error
     */
    warning?: boolean;
};

/**
 * ServiceInput
 *
 * Input for creating or updating a service deployment
 */
export type ServiceInput = {
    /**
     * Configuration values to template into the service manifests. You must pass the full list of configuration inputs
     */
    configuration?: Array<ServiceConfigurationInput>;
    /**
     * If true, does not actually apply any changes to the cluster
     */
    dry_run?: boolean;
    git?: Git;
    helm?: HelmSpecInput;
    kustomize?: KustomizeInput;
    /**
     * Desired name for the service
     */
    name: string;
    /**
     * Target deployment namespace
     */
    namespace: string;
    /**
     * If true, marks the service as protected from accidental changes
     */
    protect?: boolean;
    /**
     * Custom renderers for processing service manifests
     */
    renderers?: Array<ServiceRendererInput>;
    /**
     * ID of the backing repository for this service
     */
    repository_id?: string;
    /**
     * Additional source repositories for this service
     */
    sources?: Array<ServiceSourceInput>;
};

/**
 * ServiceRenderer
 *
 * A custom renderer for processing service manifests at a specific path
 */
export type ServiceRenderer = {
    helm?: RendererHelm;
    /**
     * Path within the repository where this renderer applies
     */
    path?: string;
    /**
     * Type of renderer (auto, raw, helm, kustomize)
     */
    type?: 'auto' | 'raw' | 'helm' | 'kustomize';
};

/**
 * ServiceRendererInput
 *
 * Input for a custom renderer configuration
 */
export type ServiceRendererInput = {
    helm?: RendererHelmInput;
    /**
     * Path within the repository where this renderer applies
     */
    path: string;
    /**
     * Type of renderer (auto, raw, helm, kustomize)
     */
    type: 'auto' | 'raw' | 'helm' | 'kustomize';
};

/**
 * ServiceSource
 *
 * An additional source repository for a service deployment
 */
export type ServiceSource = {
    git?: Git;
    /**
     * Subdirectory path where this source will live in the final tarball
     */
    path?: string;
    /**
     * ID of the git repository to source from
     */
    repository_id?: string;
};

/**
 * ServiceSourceInput
 *
 * Input for an additional source repository
 */
export type ServiceSourceInput = {
    git?: Git;
    /**
     * Subdirectory path where this source will live in the final tarball
     */
    path?: string;
    /**
     * ID of the git repository to source from
     */
    repository_id?: string;
};

/**
 * ServiceTemplate
 *
 * A service template that defines how services are created from a global service
 */
export type ServiceTemplate = {
    /**
     * List of service context names to include
     */
    contexts?: Array<string>;
    git?: Git;
    helm?: HelmSpec;
    /**
     * Unique identifier for the service template
     */
    id?: string;
    inserted_at?: string;
    kustomize?: Kustomize;
    /**
     * Name of the service to be created from this template
     */
    name?: string;
    /**
     * Kubernetes namespace for the service
     */
    namespace?: string;
    /**
     * If true, prevents accidental deletion or modification of created services
     */
    protect?: boolean;
    /**
     * ID of the git repository backing this template
     */
    repository_id?: string;
    /**
     * If true, the service configuration supports variable interpolation
     */
    templated?: boolean;
    updated_at?: string;
};

/**
 * ServiceTemplateInput
 *
 * Input for a service template configuration
 */
export type ServiceTemplateInput = {
    /**
     * List of service context names to include
     */
    contexts?: Array<string>;
    git?: Git;
    helm?: HelmSpecInput;
    kustomize?: KustomizeInput;
    /**
     * Name of the service to be created from this template
     */
    name: string;
    /**
     * Kubernetes namespace for the service
     */
    namespace: string;
    /**
     * If true, prevent accidental deletion or modification
     */
    protect?: boolean;
    /**
     * ID of the git repository backing this template
     */
    repository_id?: string;
    /**
     * If true, enable variable interpolation in service configuration
     */
    templated?: boolean;
};

/**
 * Stack
 *
 * An infrastructure stack
 */
export type Stack = {
    tags?: Array<Tag>;
    approval?: boolean;
    cluster_id?: string;
    deleted_at?: string;
    git?: Git;
    id?: string;
    inserted_at?: string;
    interval?: string;
    manage_state?: boolean;
    name?: string;
    paused?: boolean;
    project_id?: string;
    repository_id?: string;
    status?: 'queued' | 'pending' | 'running' | 'successful' | 'failed' | 'cancelled' | 'pending_approval';
    type?: 'terraform' | 'ansible' | 'custom';
    updated_at?: string;
    workdir?: string;
};

/**
 * StackInput
 *
 * An infrastructure stack input
 */
export type StackInput = {
    tags?: Array<Tag>;
    approval?: boolean;
    cluster_id?: string;
    git?: Git;
    interval?: string;
    manage_state?: boolean;
    name?: string;
    paused?: boolean;
    project_id?: string;
    repository_id?: string;
    type?: 'terraform' | 'ansible' | 'custom';
    workdir?: string;
};

/**
 * StackRun
 *
 * A stack run instance
 */
export type StackRun = {
    approval?: boolean;
    approved_at?: string;
    cancellation_reason?: string;
    cluster_id?: string;
    destroy?: boolean;
    dry_run?: boolean;
    git?: Git;
    id?: string;
    inserted_at?: string;
    manage_state?: boolean;
    message?: string;
    repository_id?: string;
    stack_id?: string;
    status?: 'queued' | 'pending' | 'running' | 'successful' | 'failed' | 'cancelled' | 'pending_approval';
    type?: 'terraform' | 'ansible' | 'custom';
    updated_at?: string;
    workdir?: string;
};

/**
 * StageService
 *
 * A service deployment within a pipeline stage
 */
export type StageService = {
    criteria?: PromotionCriteria;
    /**
     * Unique identifier for the stage service
     */
    id?: string;
    inserted_at?: string;
    /**
     * ID of the deployed service
     */
    service_id?: string;
    updated_at?: string;
};

/**
 * Tag
 *
 * A tag
 */
export type Tag = {
    name?: string;
    value?: string;
};

/**
 * TagInput
 *
 * A tag used for matching clusters
 */
export type TagInput = {
    /**
     * Tag name
     */
    name: string;
    /**
     * Tag value
     */
    value: string;
};

/**
 * User
 *
 * A registed user
 */
export type User = {
    email: string;
    id: string;
    inserted_at: string;
    roles?: ConsoleOpenApiUserRoles;
    service_account?: boolean;
    updated_at?: string;
};

export type ListAgentRunsData = {
    body?: never;
    path?: never;
    query?: {
        runtime_id?: string;
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/ai/runs';
};

export type ListAgentRunsResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiAiAgentRunList;
};

export type ListAgentRunsResponse = ListAgentRunsResponses[keyof ListAgentRunsResponses];

export type CreateAgentRunData = {
    body: AgentRunInput;
    path?: never;
    query?: never;
    url: '/v1/api/ai/runs';
};

export type CreateAgentRunResponses = {
    /**
     * no description
     */
    200: AgentRun;
};

export type CreateAgentRunResponse = CreateAgentRunResponses[keyof CreateAgentRunResponses];

export type GetAgentRunData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/ai/runs/{id}';
};

export type GetAgentRunResponses = {
    /**
     * no description
     */
    200: AgentRun;
};

export type GetAgentRunResponse = GetAgentRunResponses[keyof GetAgentRunResponses];

export type ListAgentRuntimesData = {
    body?: never;
    path?: never;
    query?: {
        type?: 'claude' | 'opencode' | 'gemini' | 'custom';
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/ai/runtimes';
};

export type ListAgentRuntimesResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiAiAgentRuntimeList;
};

export type ListAgentRuntimesResponse = ListAgentRuntimesResponses[keyof ListAgentRuntimesResponses];

export type GetAgentRuntimeData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/ai/runtimes/{id}';
};

export type GetAgentRuntimeResponses = {
    /**
     * no description
     */
    200: AgentRuntime;
};

export type GetAgentRuntimeResponse = GetAgentRuntimeResponses[keyof GetAgentRuntimeResponses];

export type GetSentinelRunData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/ai/sentinelruns/{id}';
};

export type GetSentinelRunResponses = {
    /**
     * no description
     */
    200: SentinelRun;
};

export type GetSentinelRunResponse = GetSentinelRunResponses[keyof GetSentinelRunResponses];

export type ListSentinelsData = {
    body?: never;
    path?: never;
    query?: {
        status?: 'pending' | 'success' | 'failed';
        q?: string;
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/ai/sentinels';
};

export type ListSentinelsResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiAiSentinelList;
};

export type ListSentinelsResponse = ListSentinelsResponses[keyof ListSentinelsResponses];

export type GetSentinelData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/ai/sentinels/{id}';
};

export type GetSentinelResponses = {
    /**
     * no description
     */
    200: Sentinel;
};

export type GetSentinelResponse = GetSentinelResponses[keyof GetSentinelResponses];

export type TriggerSentinelData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/ai/sentinels/{id}/trigger';
};

export type TriggerSentinelResponses = {
    /**
     * no description
     */
    200: SentinelRun;
};

export type TriggerSentinelResponse = TriggerSentinelResponses[keyof TriggerSentinelResponses];

export type ListSentinelRunsData = {
    body?: never;
    path: {
        sentinel_id: string;
    };
    query?: {
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/ai/sentinels/{sentinel_id}/runs';
};

export type ListSentinelRunsResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiAiSentinelRunList;
};

export type ListSentinelRunsResponse = ListSentinelRunsResponses[keyof ListSentinelRunsResponses];

export type ListAgentSessionsData = {
    body?: never;
    path?: never;
    query?: {
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/ai/sessions';
};

export type ListAgentSessionsResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiAiAgentSessionList;
};

export type ListAgentSessionsResponse = ListAgentSessionsResponses[keyof ListAgentSessionsResponses];

export type CreateAgentSessionData = {
    body: AgentSessionInput;
    path?: never;
    query?: never;
    url: '/v1/api/ai/sessions';
};

export type CreateAgentSessionResponses = {
    /**
     * no description
     */
    200: AgentSession;
};

export type CreateAgentSessionResponse = CreateAgentSessionResponses[keyof CreateAgentSessionResponses];

export type GetAgentSessionData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/ai/sessions/{id}';
};

export type GetAgentSessionResponses = {
    /**
     * no description
     */
    200: AgentSession;
};

export type GetAgentSessionResponse = GetAgentSessionResponses[keyof GetAgentSessionResponses];

export type ListClustersData = {
    body?: never;
    path?: never;
    query?: {
        q?: string;
        project_id?: string;
        healthy?: boolean;
        tag?: string;
        upgradeable?: boolean;
        compliance?: 'latest' | 'compliant' | 'outdated';
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/cd/clusters';
};

export type ListClustersResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiCdClusterList;
};

export type ListClustersResponse = ListClustersResponses[keyof ListClustersResponses];

export type CreateClusterData = {
    body: ClusterInput;
    path?: never;
    query?: never;
    url: '/v1/api/cd/clusters';
};

export type CreateClusterResponses = {
    /**
     * no description
     */
    200: Cluster;
};

export type CreateClusterResponse = CreateClusterResponses[keyof CreateClusterResponses];

export type DeleteClusterData = {
    body?: never;
    path: {
        id: string;
    };
    query?: {
        detach?: boolean;
    };
    url: '/v1/api/cd/clusters/{id}';
};

export type DeleteClusterResponses = {
    /**
     * no description
     */
    200: Cluster;
};

export type DeleteClusterResponse = DeleteClusterResponses[keyof DeleteClusterResponses];

export type GetClusterData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/cd/clusters/{id}';
};

export type GetClusterResponses = {
    /**
     * no description
     */
    200: Cluster;
};

export type GetClusterResponse = GetClusterResponses[keyof GetClusterResponses];

export type UpdateClusterData = {
    body: ClusterInput;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/cd/clusters/{id}';
};

export type UpdateClusterResponses = {
    /**
     * no description
     */
    200: Cluster;
};

export type UpdateClusterResponse = UpdateClusterResponses[keyof UpdateClusterResponses];

export type CreateClusterUpgradeData = {
    body: ClusterUpgradeInput;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/cd/clusters/{id}/upgrade';
};

export type CreateClusterUpgradeResponses = {
    /**
     * no description
     */
    200: ClusterUpgrade;
};

export type CreateClusterUpgradeResponse = CreateClusterUpgradeResponses[keyof CreateClusterUpgradeResponses];

export type GetClusterUpgradeData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/cd/clusterupgrade/{id}';
};

export type GetClusterUpgradeResponses = {
    /**
     * no description
     */
    200: ClusterUpgrade;
};

export type GetClusterUpgradeResponse = GetClusterUpgradeResponses[keyof GetClusterUpgradeResponses];

export type ListGitRepositoriesData = {
    body?: never;
    path?: never;
    query?: {
        q?: string;
        health?: 'pullable' | 'failed';
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/cd/git/repositories';
};

export type ListGitRepositoriesResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiCdGitRepositoryList;
};

export type ListGitRepositoriesResponse = ListGitRepositoriesResponses[keyof ListGitRepositoriesResponses];

export type CreateGitRepositoryData = {
    body: GitRepositoryInput;
    path?: never;
    query?: never;
    url: '/v1/api/cd/git/repositories';
};

export type CreateGitRepositoryResponses = {
    /**
     * no description
     */
    200: GitRepository;
};

export type CreateGitRepositoryResponse = CreateGitRepositoryResponses[keyof CreateGitRepositoryResponses];

export type GetGitRepositoryByUrlData = {
    body?: never;
    path?: never;
    query: {
        url: string;
    };
    url: '/v1/api/cd/git/repositories/url';
};

export type GetGitRepositoryByUrlResponses = {
    /**
     * no description
     */
    200: GitRepository;
};

export type GetGitRepositoryByUrlResponse = GetGitRepositoryByUrlResponses[keyof GetGitRepositoryByUrlResponses];

export type DeleteGitRepositoryData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/cd/git/repositories/{id}';
};

export type DeleteGitRepositoryResponses = {
    /**
     * no description
     */
    200: GitRepository;
};

export type DeleteGitRepositoryResponse = DeleteGitRepositoryResponses[keyof DeleteGitRepositoryResponses];

export type GetGitRepositoryData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/cd/git/repositories/{id}';
};

export type GetGitRepositoryResponses = {
    /**
     * no description
     */
    200: GitRepository;
};

export type GetGitRepositoryResponse = GetGitRepositoryResponses[keyof GetGitRepositoryResponses];

export type UpdateGitRepositoryData = {
    body: GitRepositoryInput;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/cd/git/repositories/{id}';
};

export type UpdateGitRepositoryResponses = {
    /**
     * no description
     */
    200: GitRepository;
};

export type UpdateGitRepositoryResponse = UpdateGitRepositoryResponses[keyof UpdateGitRepositoryResponses];

export type ListGlobalServicesData = {
    body?: never;
    path?: never;
    query?: {
        project_id?: string;
        q?: string;
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/cd/globalservices';
};

export type ListGlobalServicesResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiCdGlobalServiceList;
};

export type ListGlobalServicesResponse = ListGlobalServicesResponses[keyof ListGlobalServicesResponses];

export type CreateGlobalServiceData = {
    body: GlobalServiceInput;
    path?: never;
    query?: {
        service_id?: string;
    };
    url: '/v1/api/cd/globalservices';
};

export type CreateGlobalServiceResponses = {
    /**
     * no description
     */
    200: GlobalService;
};

export type CreateGlobalServiceResponse = CreateGlobalServiceResponses[keyof CreateGlobalServiceResponses];

export type DeleteGlobalServiceData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/cd/globalservices/{id}';
};

export type DeleteGlobalServiceResponses = {
    /**
     * no description
     */
    200: GlobalService;
};

export type DeleteGlobalServiceResponse = DeleteGlobalServiceResponses[keyof DeleteGlobalServiceResponses];

export type GetGlobalServiceData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/cd/globalservices/{id}';
};

export type GetGlobalServiceResponses = {
    /**
     * no description
     */
    200: GlobalService;
};

export type GetGlobalServiceResponse = GetGlobalServiceResponses[keyof GetGlobalServiceResponses];

export type UpdateGlobalServiceData = {
    body: GlobalServiceInput;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/cd/globalservices/{id}';
};

export type UpdateGlobalServiceResponses = {
    /**
     * no description
     */
    200: GlobalService;
};

export type UpdateGlobalServiceResponse = UpdateGlobalServiceResponses[keyof UpdateGlobalServiceResponses];

export type SyncGlobalServiceData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/cd/globalservices/{id}/sync';
};

export type SyncGlobalServiceResponses = {
    /**
     * no description
     */
    200: GlobalService;
};

export type SyncGlobalServiceResponse = SyncGlobalServiceResponses[keyof SyncGlobalServiceResponses];

export type ListHelmRepositoriesData = {
    body?: never;
    path?: never;
    query?: {
        q?: string;
        health?: 'pullable' | 'failed';
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/cd/helm/repositories';
};

export type ListHelmRepositoriesResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiCdHelmRepositoryList;
};

export type ListHelmRepositoriesResponse = ListHelmRepositoriesResponses[keyof ListHelmRepositoriesResponses];

export type UpsertHelmRepositoryData = {
    body: HelmRepositoryInput;
    path?: never;
    query?: never;
    url: '/v1/api/cd/helm/repositories';
};

export type UpsertHelmRepositoryResponses = {
    /**
     * no description
     */
    200: HelmRepository;
};

export type UpsertHelmRepositoryResponse = UpsertHelmRepositoryResponses[keyof UpsertHelmRepositoryResponses];

export type GetHelmRepositoryByUrlData = {
    body?: never;
    path?: never;
    query: {
        url: string;
    };
    url: '/v1/api/cd/helm/repositories/url';
};

export type GetHelmRepositoryByUrlResponses = {
    /**
     * no description
     */
    200: HelmRepository;
};

export type GetHelmRepositoryByUrlResponse = GetHelmRepositoryByUrlResponses[keyof GetHelmRepositoryByUrlResponses];

export type GetHelmRepositoryData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/cd/helm/repositories/{id}';
};

export type GetHelmRepositoryResponses = {
    /**
     * no description
     */
    200: HelmRepository;
};

export type GetHelmRepositoryResponse = GetHelmRepositoryResponses[keyof GetHelmRepositoryResponses];

export type ListPipelinesData = {
    body?: never;
    path?: never;
    query?: {
        project_id?: string;
        q?: string;
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/cd/pipelines';
};

export type ListPipelinesResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiCdPipelineList;
};

export type ListPipelinesResponse = ListPipelinesResponses[keyof ListPipelinesResponses];

export type GetPipelineData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/cd/pipelines/{id}';
};

export type GetPipelineResponses = {
    /**
     * no description
     */
    200: Pipeline;
};

export type GetPipelineResponse = GetPipelineResponses[keyof GetPipelineResponses];

export type TriggerPipelineData = {
    body: PipelineContextInput;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/cd/pipelines/{id}/trigger';
};

export type TriggerPipelineResponses = {
    /**
     * no description
     */
    200: PipelineContext;
};

export type TriggerPipelineResponse = TriggerPipelineResponses[keyof TriggerPipelineResponses];

export type ListServicesData = {
    body?: never;
    path?: never;
    query?: {
        cluster_id?: string;
        status?: string;
        q?: string;
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/cd/services';
};

export type ListServicesResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiCdServiceList;
};

export type ListServicesResponse = ListServicesResponses[keyof ListServicesResponses];

export type CreateServiceData = {
    body: ServiceInput;
    path?: never;
    query: {
        cluster_id: string;
    };
    url: '/v1/api/cd/services';
};

export type CreateServiceResponses = {
    /**
     * no description
     */
    200: Service;
};

export type CreateServiceResponse = CreateServiceResponses[keyof CreateServiceResponses];

export type DeleteServiceData = {
    body?: never;
    path: {
        id: string;
    };
    query?: {
        detach?: boolean;
    };
    url: '/v1/api/cd/services/{id}';
};

export type DeleteServiceResponses = {
    /**
     * no description
     */
    200: Service;
};

export type DeleteServiceResponse = DeleteServiceResponses[keyof DeleteServiceResponses];

export type GetServiceData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/cd/services/{id}';
};

export type GetServiceResponses = {
    /**
     * no description
     */
    200: Service;
};

export type GetServiceResponse = GetServiceResponses[keyof GetServiceResponses];

export type UpdateServiceData = {
    body: ServiceInput;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/cd/services/{id}';
};

export type UpdateServiceResponses = {
    /**
     * no description
     */
    200: Service;
};

export type UpdateServiceResponse = UpdateServiceResponses[keyof UpdateServiceResponses];

export type MeData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/api/me';
};

export type MeResponses = {
    /**
     * no description
     */
    200: User;
};

export type MeResponse = MeResponses[keyof MeResponses];

export type ListProjectsData = {
    body?: never;
    path?: never;
    query?: {
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/projects';
};

export type ListProjectsResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiProjectList;
};

export type ListProjectsResponse = ListProjectsResponses[keyof ListProjectsResponses];

export type GetProjectData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/projects/{id}';
};

export type GetProjectResponses = {
    /**
     * no description
     */
    200: Project;
};

export type GetProjectResponse = GetProjectResponses[keyof GetProjectResponses];

export type ListCatalogsData = {
    body?: never;
    path?: never;
    query?: {
        project_id?: string;
        q?: string;
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/scm/catalogs';
};

export type ListCatalogsResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiScmCatalogList;
};

export type ListCatalogsResponse = ListCatalogsResponses[keyof ListCatalogsResponses];

export type UpsertCatalogData = {
    body: CatalogInput;
    path?: never;
    query?: never;
    url: '/v1/api/scm/catalogs';
};

export type UpsertCatalogResponses = {
    /**
     * no description
     */
    200: Catalog;
};

export type UpsertCatalogResponse = UpsertCatalogResponses[keyof UpsertCatalogResponses];

export type ListPrAutomationsForCatalogData = {
    body?: never;
    path: {
        catalog_id: string;
    };
    query?: {
        q?: string;
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/scm/catalogs/{catalog_id}/prautomations';
};

export type ListPrAutomationsForCatalogResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiScmPrAutomationList;
};

export type ListPrAutomationsForCatalogResponse = ListPrAutomationsForCatalogResponses[keyof ListPrAutomationsForCatalogResponses];

export type DeleteCatalogData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/scm/catalogs/{id}';
};

export type DeleteCatalogResponses = {
    /**
     * no description
     */
    200: Catalog;
};

export type DeleteCatalogResponse = DeleteCatalogResponses[keyof DeleteCatalogResponses];

export type GetCatalogData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/scm/catalogs/{id}';
};

export type GetCatalogResponses = {
    /**
     * no description
     */
    200: Catalog;
};

export type GetCatalogResponse = GetCatalogResponses[keyof GetCatalogResponses];

export type UpdateCatalogData = {
    body: CatalogInput;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/scm/catalogs/{id}';
};

export type UpdateCatalogResponses = {
    /**
     * no description
     */
    200: Catalog;
};

export type UpdateCatalogResponse = UpdateCatalogResponses[keyof UpdateCatalogResponses];

export type ListScmConnectionsData = {
    body?: never;
    path?: never;
    query?: {
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/scm/connections';
};

export type ListScmConnectionsResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiScmConnectionList;
};

export type ListScmConnectionsResponse = ListScmConnectionsResponses[keyof ListScmConnectionsResponses];

export type CreateScmConnectionData = {
    body: ScmConnectionInput;
    path?: never;
    query?: never;
    url: '/v1/api/scm/connections';
};

export type CreateScmConnectionResponses = {
    /**
     * no description
     */
    200: ScmConnection;
};

export type CreateScmConnectionResponse = CreateScmConnectionResponses[keyof CreateScmConnectionResponses];

export type DeleteScmConnectionData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/scm/connections/{id}';
};

export type DeleteScmConnectionResponses = {
    /**
     * no description
     */
    200: ScmConnection;
};

export type DeleteScmConnectionResponse = DeleteScmConnectionResponses[keyof DeleteScmConnectionResponses];

export type GetScmConnectionData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/scm/connections/{id}';
};

export type GetScmConnectionResponses = {
    /**
     * no description
     */
    200: ScmConnection;
};

export type GetScmConnectionResponse = GetScmConnectionResponses[keyof GetScmConnectionResponses];

export type UpdateScmConnectionData = {
    body: ScmConnectionInput;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/scm/connections/{id}';
};

export type UpdateScmConnectionResponses = {
    /**
     * no description
     */
    200: ScmConnection;
};

export type UpdateScmConnectionResponse = UpdateScmConnectionResponses[keyof UpdateScmConnectionResponses];

export type ListPrAutomationsData = {
    body?: never;
    path?: never;
    query?: {
        project_id?: string;
        catalog_id?: string;
        q?: string;
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/scm/prautomations';
};

export type ListPrAutomationsResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiScmPrAutomationList;
};

export type ListPrAutomationsResponse = ListPrAutomationsResponses[keyof ListPrAutomationsResponses];

export type GetPrAutomationData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/scm/prautomations/{id}';
};

export type GetPrAutomationResponses = {
    /**
     * no description
     */
    200: PrAutomation;
};

export type GetPrAutomationResponse = GetPrAutomationResponses[keyof GetPrAutomationResponses];

export type InvokePrAutomationData = {
    body: CreatePullRequestInput;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/scm/prautomations/{id}/invoke';
};

export type InvokePrAutomationResponses = {
    /**
     * no description
     */
    200: PullRequest;
};

export type InvokePrAutomationResponse = InvokePrAutomationResponses[keyof InvokePrAutomationResponses];

export type ListPullRequestsData = {
    body?: never;
    path?: never;
    query?: {
        cluster_id?: string;
        service_id?: string;
        stack_id?: string;
        open?: boolean;
        q?: string;
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/scm/pullrequests';
};

export type ListPullRequestsResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiScmPullRequestList;
};

export type ListPullRequestsResponse = ListPullRequestsResponses[keyof ListPullRequestsResponses];

export type GetPullRequestData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/scm/pullrequests/{id}';
};

export type GetPullRequestResponses = {
    /**
     * no description
     */
    200: PullRequest;
};

export type GetPullRequestResponse = GetPullRequestResponses[keyof GetPullRequestResponses];

export type ListServiceAccountsData = {
    body?: never;
    path?: never;
    query?: {
        q?: string;
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/serviceaccounts';
};

export type ListServiceAccountsResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiUserList;
};

export type ListServiceAccountsResponse = ListServiceAccountsResponses[keyof ListServiceAccountsResponses];

export type GetServiceAccountByEmailData = {
    body?: never;
    path: {
        email: string;
    };
    query?: never;
    url: '/v1/api/serviceaccounts/email/{email}';
};

export type GetServiceAccountByEmailResponses = {
    /**
     * no description
     */
    200: User;
};

export type GetServiceAccountByEmailResponse = GetServiceAccountByEmailResponses[keyof GetServiceAccountByEmailResponses];

export type GetServiceAccountData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/serviceaccounts/{id}';
};

export type GetServiceAccountResponses = {
    /**
     * no description
     */
    200: User;
};

export type GetServiceAccountResponse = GetServiceAccountResponses[keyof GetServiceAccountResponses];

export type CreateServiceAccountAccessTokenData = {
    body: AccessTokenInput;
    path: {
        id: string;
    };
    query?: {
        refresh?: boolean;
    };
    url: '/v1/api/serviceaccounts/{id}/token';
};

export type CreateServiceAccountAccessTokenResponses = {
    /**
     * no description
     */
    200: AccessToken;
};

export type CreateServiceAccountAccessTokenResponse = CreateServiceAccountAccessTokenResponses[keyof CreateServiceAccountAccessTokenResponses];

export type ListStacksData = {
    body?: never;
    path?: never;
    query?: {
        page?: number;
        per_page?: number;
    };
    url: '/v1/api/stacks';
};

export type ListStacksResponses = {
    /**
     * no description
     */
    200: ConsoleOpenApiStackList;
};

export type ListStacksResponse = ListStacksResponses[keyof ListStacksResponses];

export type CreateStackData = {
    body: StackInput;
    path?: never;
    query?: never;
    url: '/v1/api/stacks';
};

export type CreateStackResponses = {
    /**
     * no description
     */
    200: Stack;
};

export type CreateStackResponse = CreateStackResponses[keyof CreateStackResponses];

export type DeleteStackData = {
    body?: never;
    path: {
        id: string;
    };
    query?: {
        detach?: boolean;
    };
    url: '/v1/api/stacks/{id}';
};

export type DeleteStackResponses = {
    /**
     * no description
     */
    200: Stack;
};

export type DeleteStackResponse = DeleteStackResponses[keyof DeleteStackResponses];

export type GetStackData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/stacks/{id}';
};

export type GetStackResponses = {
    /**
     * no description
     */
    200: Stack;
};

export type GetStackResponse = GetStackResponses[keyof GetStackResponses];

export type UpdateStackData = {
    body: StackInput;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/stacks/{id}';
};

export type UpdateStackResponses = {
    /**
     * no description
     */
    200: Stack;
};

export type UpdateStackResponse = UpdateStackResponses[keyof UpdateStackResponses];

export type RestoreStackData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/stacks/{id}/restore';
};

export type RestoreStackResponses = {
    /**
     * no description
     */
    200: Stack;
};

export type RestoreStackResponse = RestoreStackResponses[keyof RestoreStackResponses];

export type ResyncStackData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/stacks/{id}/resync';
};

export type ResyncStackResponses = {
    /**
     * no description
     */
    200: StackRun;
};

export type ResyncStackResponse = ResyncStackResponses[keyof ResyncStackResponses];

export type TriggerStackRunData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/api/stacks/{id}/trigger';
};

export type TriggerStackRunResponses = {
    /**
     * no description
     */
    200: StackRun;
};

export type TriggerStackRunResponse = TriggerStackRunResponses[keyof TriggerStackRunResponses];
