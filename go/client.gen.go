// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.0 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AgentRunLanguage.
const (
	AgentRunLanguageCpp        AgentRunLanguage = "cpp"
	AgentRunLanguageCsharp     AgentRunLanguage = "csharp"
	AgentRunLanguageGo         AgentRunLanguage = "go"
	AgentRunLanguageJava       AgentRunLanguage = "java"
	AgentRunLanguageJavascript AgentRunLanguage = "javascript"
	AgentRunLanguagePhp        AgentRunLanguage = "php"
	AgentRunLanguagePython     AgentRunLanguage = "python"
	AgentRunLanguageRuby       AgentRunLanguage = "ruby"
	AgentRunLanguageTerraform  AgentRunLanguage = "terraform"
)

// Defines values for AgentRunMode.
const (
	AgentRunModeAnalyze AgentRunMode = "analyze"
	AgentRunModeWrite   AgentRunMode = "write"
)

// Defines values for AgentRunStatus.
const (
	AgentRunStatusCancelled  AgentRunStatus = "cancelled"
	AgentRunStatusFailed     AgentRunStatus = "failed"
	AgentRunStatusPending    AgentRunStatus = "pending"
	AgentRunStatusRunning    AgentRunStatus = "running"
	AgentRunStatusSuccessful AgentRunStatus = "successful"
)

// Defines values for AgentRunInputMode.
const (
	AgentRunInputModeAnalyze AgentRunInputMode = "analyze"
	AgentRunInputModeWrite   AgentRunInputMode = "write"
)

// Defines values for AgentRuntimeType.
const (
	AgentRuntimeTypeClaude   AgentRuntimeType = "claude"
	AgentRuntimeTypeCustom   AgentRuntimeType = "custom"
	AgentRuntimeTypeGemini   AgentRuntimeType = "gemini"
	AgentRuntimeTypeOpencode AgentRuntimeType = "opencode"
)

// Defines values for AgentSessionType.
const (
	AgentSessionTypeChat         AgentSessionType = "chat"
	AgentSessionTypeKubernetes   AgentSessionType = "kubernetes"
	AgentSessionTypeManifests    AgentSessionType = "manifests"
	AgentSessionTypeProvisioning AgentSessionType = "provisioning"
	AgentSessionTypeResearch     AgentSessionType = "research"
	AgentSessionTypeSearch       AgentSessionType = "search"
	AgentSessionTypeTerraform    AgentSessionType = "terraform"
)

// Defines values for ClusterDistro.
const (
	ClusterDistroAks       ClusterDistro = "aks"
	ClusterDistroEks       ClusterDistro = "eks"
	ClusterDistroGeneric   ClusterDistro = "generic"
	ClusterDistroGke       ClusterDistro = "gke"
	ClusterDistroK3s       ClusterDistro = "k3s"
	ClusterDistroOpenshift ClusterDistro = "openshift"
	ClusterDistroRke       ClusterDistro = "rke"
)

// Defines values for ClusterUpgradeStatus.
const (
	ClusterUpgradeStatusCompleted  ClusterUpgradeStatus = "completed"
	ClusterUpgradeStatusFailed     ClusterUpgradeStatus = "failed"
	ClusterUpgradeStatusInProgress ClusterUpgradeStatus = "in_progress"
	ClusterUpgradeStatusPending    ClusterUpgradeStatus = "pending"
)

// Defines values for ClusterUpgradeStepStatus.
const (
	ClusterUpgradeStepStatusCompleted  ClusterUpgradeStepStatus = "completed"
	ClusterUpgradeStepStatusFailed     ClusterUpgradeStepStatus = "failed"
	ClusterUpgradeStepStatusInProgress ClusterUpgradeStepStatus = "in_progress"
	ClusterUpgradeStepStatusPending    ClusterUpgradeStepStatus = "pending"
)

// Defines values for ClusterUpgradeStepType.
const (
	Addon          ClusterUpgradeStepType = "addon"
	CloudAddon     ClusterUpgradeStepType = "cloud_addon"
	Infrastructure ClusterUpgradeStepType = "infrastructure"
)

// Defines values for GitRepositoryAuthMethod.
const (
	GitRepositoryAuthMethodBasic GitRepositoryAuthMethod = "basic"
	GitRepositoryAuthMethodSsh   GitRepositoryAuthMethod = "ssh"
)

// Defines values for GitRepositoryHealth.
const (
	GitRepositoryHealthFailed   GitRepositoryHealth = "failed"
	GitRepositoryHealthPullable GitRepositoryHealth = "pullable"
)

// Defines values for GlobalServiceDistro.
const (
	GlobalServiceDistroAks       GlobalServiceDistro = "aks"
	GlobalServiceDistroEks       GlobalServiceDistro = "eks"
	GlobalServiceDistroGeneric   GlobalServiceDistro = "generic"
	GlobalServiceDistroGke       GlobalServiceDistro = "gke"
	GlobalServiceDistroK3s       GlobalServiceDistro = "k3s"
	GlobalServiceDistroOpenshift GlobalServiceDistro = "openshift"
	GlobalServiceDistroRke       GlobalServiceDistro = "rke"
)

// Defines values for GlobalServiceInputDistro.
const (
	Aks       GlobalServiceInputDistro = "aks"
	Eks       GlobalServiceInputDistro = "eks"
	Generic   GlobalServiceInputDistro = "generic"
	Gke       GlobalServiceInputDistro = "gke"
	K3s       GlobalServiceInputDistro = "k3s"
	Openshift GlobalServiceInputDistro = "openshift"
	Rke       GlobalServiceInputDistro = "rke"
)

// Defines values for HelmRepositoryHealth.
const (
	HelmRepositoryHealthFailed   HelmRepositoryHealth = "failed"
	HelmRepositoryHealthPullable HelmRepositoryHealth = "pullable"
)

// Defines values for HelmRepositoryProvider.
const (
	HelmRepositoryProviderAws    HelmRepositoryProvider = "aws"
	HelmRepositoryProviderAzure  HelmRepositoryProvider = "azure"
	HelmRepositoryProviderBasic  HelmRepositoryProvider = "basic"
	HelmRepositoryProviderBearer HelmRepositoryProvider = "bearer"
	HelmRepositoryProviderGcp    HelmRepositoryProvider = "gcp"
)

// Defines values for HelmRepositoryInputProvider.
const (
	Aws    HelmRepositoryInputProvider = "aws"
	Azure  HelmRepositoryInputProvider = "azure"
	Basic  HelmRepositoryInputProvider = "basic"
	Bearer HelmRepositoryInputProvider = "bearer"
	Gcp    HelmRepositoryInputProvider = "gcp"
)

// Defines values for PipelineGateState.
const (
	PipelineGateStateClosed  PipelineGateState = "closed"
	PipelineGateStateOpen    PipelineGateState = "open"
	PipelineGateStatePending PipelineGateState = "pending"
	PipelineGateStateRunning PipelineGateState = "running"
)

// Defines values for PipelineGateType.
const (
	PipelineGateTypeApproval PipelineGateType = "approval"
	PipelineGateTypeJob      PipelineGateType = "job"
	PipelineGateTypeSentinel PipelineGateType = "sentinel"
	PipelineGateTypeWindow   PipelineGateType = "window"
)

// Defines values for PrConfigurationType.
const (
	PrConfigurationTypeBool     PrConfigurationType = "bool"
	PrConfigurationTypeBucket   PrConfigurationType = "bucket"
	PrConfigurationTypeCluster  PrConfigurationType = "cluster"
	PrConfigurationTypeDomain   PrConfigurationType = "domain"
	PrConfigurationTypeEnum     PrConfigurationType = "enum"
	PrConfigurationTypeFile     PrConfigurationType = "file"
	PrConfigurationTypeFlow     PrConfigurationType = "flow"
	PrConfigurationTypeFunction PrConfigurationType = "function"
	PrConfigurationTypeGroup    PrConfigurationType = "group"
	PrConfigurationTypeInt      PrConfigurationType = "int"
	PrConfigurationTypeJson     PrConfigurationType = "json"
	PrConfigurationTypePassword PrConfigurationType = "password"
	PrConfigurationTypeProject  PrConfigurationType = "project"
	PrConfigurationTypeString   PrConfigurationType = "string"
	PrConfigurationTypeUser     PrConfigurationType = "user"
)

// Defines values for PullRequestStatus.
const (
	PullRequestStatusClosed PullRequestStatus = "closed"
	PullRequestStatusMerged PullRequestStatus = "merged"
	PullRequestStatusOpen   PullRequestStatus = "open"
)

// Defines values for ScmConnectionType.
const (
	ScmConnectionTypeAzureDevops         ScmConnectionType = "azure_devops"
	ScmConnectionTypeBitbucket           ScmConnectionType = "bitbucket"
	ScmConnectionTypeBitbucketDatacenter ScmConnectionType = "bitbucket_datacenter"
	ScmConnectionTypeGithub              ScmConnectionType = "github"
	ScmConnectionTypeGitlab              ScmConnectionType = "gitlab"
)

// Defines values for ScmConnectionInputType.
const (
	ScmConnectionInputTypeAzureDevops         ScmConnectionInputType = "azure_devops"
	ScmConnectionInputTypeBitbucket           ScmConnectionInputType = "bitbucket"
	ScmConnectionInputTypeBitbucketDatacenter ScmConnectionInputType = "bitbucket_datacenter"
	ScmConnectionInputTypeGithub              ScmConnectionInputType = "github"
	ScmConnectionInputTypeGitlab              ScmConnectionInputType = "gitlab"
)

// Defines values for SentinelStatus.
const (
	SentinelStatusFailed  SentinelStatus = "failed"
	SentinelStatusPending SentinelStatus = "pending"
	SentinelStatusSuccess SentinelStatus = "success"
)

// Defines values for SentinelCheckType.
const (
	IntegrationTest SentinelCheckType = "integration_test"
	Kubernetes      SentinelCheckType = "kubernetes"
	Log             SentinelCheckType = "log"
)

// Defines values for SentinelCheckResultStatus.
const (
	SentinelCheckResultStatusFailed  SentinelCheckResultStatus = "failed"
	SentinelCheckResultStatusPending SentinelCheckResultStatus = "pending"
	SentinelCheckResultStatusSuccess SentinelCheckResultStatus = "success"
)

// Defines values for SentinelRunStatus.
const (
	SentinelRunStatusFailed  SentinelRunStatus = "failed"
	SentinelRunStatusPending SentinelRunStatus = "pending"
	SentinelRunStatusSuccess SentinelRunStatus = "success"
)

// Defines values for SentinelRunJobFormat.
const (
	Junit     SentinelRunJobFormat = "junit"
	Plaintext SentinelRunJobFormat = "plaintext"
)

// Defines values for SentinelRunJobStatus.
const (
	SentinelRunJobStatusFailed  SentinelRunJobStatus = "failed"
	SentinelRunJobStatusPending SentinelRunJobStatus = "pending"
	SentinelRunJobStatusRunning SentinelRunJobStatus = "running"
	SentinelRunJobStatusSuccess SentinelRunJobStatus = "success"
)

// Defines values for ServiceStatus.
const (
	ServiceStatusFailed  ServiceStatus = "failed"
	ServiceStatusHealthy ServiceStatus = "healthy"
	ServiceStatusPaused  ServiceStatus = "paused"
	ServiceStatusStale   ServiceStatus = "stale"
	ServiceStatusSynced  ServiceStatus = "synced"
)

// Defines values for ServiceRendererType.
const (
	ServiceRendererTypeAuto      ServiceRendererType = "auto"
	ServiceRendererTypeHelm      ServiceRendererType = "helm"
	ServiceRendererTypeKustomize ServiceRendererType = "kustomize"
	ServiceRendererTypeRaw       ServiceRendererType = "raw"
)

// Defines values for ServiceRendererInputType.
const (
	ServiceRendererInputTypeAuto      ServiceRendererInputType = "auto"
	ServiceRendererInputTypeHelm      ServiceRendererInputType = "helm"
	ServiceRendererInputTypeKustomize ServiceRendererInputType = "kustomize"
	ServiceRendererInputTypeRaw       ServiceRendererInputType = "raw"
)

// Defines values for StackStatus.
const (
	StackStatusCancelled       StackStatus = "cancelled"
	StackStatusFailed          StackStatus = "failed"
	StackStatusPending         StackStatus = "pending"
	StackStatusPendingApproval StackStatus = "pending_approval"
	StackStatusQueued          StackStatus = "queued"
	StackStatusRunning         StackStatus = "running"
	StackStatusSuccessful      StackStatus = "successful"
)

// Defines values for StackType.
const (
	StackTypeAnsible   StackType = "ansible"
	StackTypeCustom    StackType = "custom"
	StackTypeTerraform StackType = "terraform"
)

// Defines values for StackInputType.
const (
	StackInputTypeAnsible   StackInputType = "ansible"
	StackInputTypeCustom    StackInputType = "custom"
	StackInputTypeTerraform StackInputType = "terraform"
)

// Defines values for StackRunStatus.
const (
	StackRunStatusCancelled       StackRunStatus = "cancelled"
	StackRunStatusFailed          StackRunStatus = "failed"
	StackRunStatusPending         StackRunStatus = "pending"
	StackRunStatusPendingApproval StackRunStatus = "pending_approval"
	StackRunStatusQueued          StackRunStatus = "queued"
	StackRunStatusRunning         StackRunStatus = "running"
	StackRunStatusSuccessful      StackRunStatus = "successful"
)

// Defines values for StackRunType.
const (
	StackRunTypeAnsible   StackRunType = "ansible"
	StackRunTypeCustom    StackRunType = "custom"
	StackRunTypeTerraform StackRunType = "terraform"
)

// Defines values for ListAgentRuntimesParamsType.
const (
	Claude   ListAgentRuntimesParamsType = "claude"
	Custom   ListAgentRuntimesParamsType = "custom"
	Gemini   ListAgentRuntimesParamsType = "gemini"
	Opencode ListAgentRuntimesParamsType = "opencode"
)

// Defines values for ListSentinelsParamsStatus.
const (
	Failed  ListSentinelsParamsStatus = "failed"
	Pending ListSentinelsParamsStatus = "pending"
	Success ListSentinelsParamsStatus = "success"
)

// Defines values for ListClustersParamsCompliance.
const (
	Compliant ListClustersParamsCompliance = "compliant"
	Latest    ListClustersParamsCompliance = "latest"
	Outdated  ListClustersParamsCompliance = "outdated"
)

// AccessToken An access token
type AccessToken struct {
	ExpiresAt  *time.Time                        `json:"expires_at,omitempty"`
	Id         string                            `json:"id"`
	InsertedAt time.Time                         `json:"inserted_at"`
	LastUsedAt *time.Time                        `json:"last_used_at,omitempty"`
	Scopes     *[]ConsoleOpenAPIAccessTokenScope `json:"scopes,omitempty"`
	Token      string                            `json:"token"`
	UpdatedAt  *time.Time                        `json:"updated_at,omitempty"`
}

// AccessTokenInput Input for creating a service account access token
type AccessTokenInput struct {
	// Expiry Token TTL, e.g. 1h, 1d, 1w
	Expiry *string                           `json:"expiry,omitempty"`
	Scopes *[]ConsoleOpenAPIAccessTokenScope `json:"scopes,omitempty"`
}

// AgentRun An execution of an AI coding agent processing a prompt against a repository
type AgentRun struct {
	// Branch The git branch the agent is operating on (uses default branch if not set)
	Branch *string `json:"branch,omitempty"`

	// Error Error message if the agent run failed
	Error *string `json:"error,omitempty"`

	// FlowId ID of the flow this agent run is associated with, if any
	FlowId *string `json:"flow_id,omitempty"`

	// Id Unique identifier for the agent run
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// Language Programming language used in the agent run (javascript, python, java, cpp, csharp, go, ruby, php, terraform)
	Language *AgentRunLanguage `json:"language,omitempty"`

	// LanguageVersion Specific version of the programming language to use
	LanguageVersion *string `json:"language_version,omitempty"`

	// Mode Mode of the agent run (analyze for read-only analysis, write for code modifications)
	Mode *AgentRunMode `json:"mode,omitempty"`

	// Prompt The prompt given to the AI agent to process
	Prompt *string `json:"prompt,omitempty"`

	// Repository The git repository URL the agent is working on
	Repository *string `json:"repository,omitempty"`

	// RuntimeId ID of the runtime executing this agent run
	RuntimeId *string `json:"runtime_id,omitempty"`

	// Shared Whether this agent run is shared publicly
	Shared *bool `json:"shared,omitempty"`

	// Status Current status of the agent run (pending, running, successful, failed, cancelled)
	Status    *AgentRunStatus `json:"status,omitempty"`
	UpdatedAt *time.Time      `json:"updated_at,omitempty"`

	// UserId ID of the user who initiated this agent run
	UserId *string `json:"user_id,omitempty"`
}

// AgentRunLanguage Programming language used in the agent run (javascript, python, java, cpp, csharp, go, ruby, php, terraform)
type AgentRunLanguage string

// AgentRunMode Mode of the agent run (analyze for read-only analysis, write for code modifications)
type AgentRunMode string

// AgentRunStatus Current status of the agent run (pending, running, successful, failed, cancelled)
type AgentRunStatus string

// AgentRunInput Input for creating a new agent run to execute an AI coding agent
type AgentRunInput struct {
	// FlowId Optional flow ID to associate this agent run with
	FlowId *string `json:"flow_id,omitempty"`

	// Mode Mode of the agent run (analyze for read-only, write for modifications)
	Mode AgentRunInputMode `json:"mode"`

	// Prompt The prompt to give to the agent describing the task to perform
	Prompt string `json:"prompt"`

	// Repository The git repository URL the agent will work on (https or ssh format)
	Repository string `json:"repository"`

	// RuntimeId The runtime ID to execute the agent run on
	RuntimeId string `json:"runtime_id"`

	// Shared Whether to share this agent run publicly
	Shared *bool `json:"shared,omitempty"`
}

// AgentRunInputMode Mode of the agent run (analyze for read-only, write for modifications)
type AgentRunInputMode string

// AgentRuntime An agent runtime configured on a cluster for executing AI coding agents
type AgentRuntime struct {
	// AiProxy Whether this runtime uses the built-in Plural AI proxy for LLM requests
	AiProxy *bool `json:"ai_proxy,omitempty"`

	// ClusterId ID of the cluster this runtime is deployed on
	ClusterId *string `json:"cluster_id,omitempty"`

	// Default Whether this is the default runtime for coding agents
	Default *bool `json:"default,omitempty"`

	// Id Unique identifier for the agent runtime
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// Name Human-readable name of this runtime
	Name *string `json:"name,omitempty"`

	// Type Type of agent runtime (claude, opencode, gemini, custom)
	Type      *AgentRuntimeType `json:"type,omitempty"`
	UpdatedAt *time.Time        `json:"updated_at,omitempty"`
}

// AgentRuntimeType Type of agent runtime (claude, opencode, gemini, custom)
type AgentRuntimeType string

// AgentSession An autonomous AI agent session working on infrastructure tasks
type AgentSession struct {
	// AgentId Internal agent identifier
	AgentId *string `json:"agent_id,omitempty"`

	// Branch The git branch this session's pull request is operating on
	Branch *string `json:"branch,omitempty"`

	// ClusterId ID of the cluster associated with this session
	ClusterId *string `json:"cluster_id,omitempty"`

	// CommitCount Number of commits made by this agent session
	CommitCount *int `json:"commit_count,omitempty"`

	// ConnectionId ID of the cloud connection used by this session
	ConnectionId *string `json:"connection_id,omitempty"`

	// Done Whether the agent has declared the work for this session complete
	Done *bool `json:"done,omitempty"`

	// Id Unique identifier for the agent session
	Id *string `json:"id,omitempty"`

	// Initialized Whether the agent session has been initialized
	Initialized *bool      `json:"initialized,omitempty"`
	InsertedAt  *time.Time `json:"inserted_at,omitempty"`

	// PlanConfirmed Whether the provisioning plan has been confirmed by the user
	PlanConfirmed *bool `json:"plan_confirmed,omitempty"`

	// Prompt The prompt given to the agent
	Prompt *string `json:"prompt,omitempty"`

	// PullRequestId ID of the pull request created by this session
	PullRequestId *string `json:"pull_request_id,omitempty"`

	// ServiceId ID of the service associated with this session
	ServiceId *string `json:"service_id,omitempty"`

	// StackId ID of the infrastructure stack associated with this session
	StackId *string `json:"stack_id,omitempty"`

	// ThreadId ID of the chat thread associated with this session
	ThreadId *string `json:"thread_id,omitempty"`

	// Type Type of agent session (terraform, kubernetes, provisioning, search, manifests, chat, research)
	Type      *AgentSessionType `json:"type,omitempty"`
	UpdatedAt *time.Time        `json:"updated_at,omitempty"`
}

// AgentSessionType Type of agent session (terraform, kubernetes, provisioning, search, manifests, chat, research)
type AgentSessionType string

// AgentSessionInput Input for creating a new agent session to execute autonomous infrastructure tasks
type AgentSessionInput struct {
	// ClusterId ID of the cluster to use for this session
	ClusterId *string `json:"cluster_id,omitempty"`

	// ConnectionId ID of the cloud connection to use for this session
	ConnectionId *string `json:"connection_id,omitempty"`

	// Done Whether to immediately mark this session as done
	Done *bool `json:"done,omitempty"`

	// PlanConfirmed Whether the provisioning plan is pre-confirmed
	PlanConfirmed *bool `json:"plan_confirmed,omitempty"`

	// Prompt The prompt describing the task for the agent to perform
	Prompt string `json:"prompt"`

	// Type Type of agent session (terraform, kubernetes)
	Type *interface{} `json:"type,omitempty"`
}

// Cascade Cascade behavior when the global service is deleted
type Cascade struct {
	// Delete If true, cascade delete all services owned by this global service
	Delete *bool `json:"delete,omitempty"`

	// Detach If true, immediately detach services from the database without draining
	Detach *bool `json:"detach,omitempty"`
}

// CascadeInput Input for cascade behavior when the global service is deleted
type CascadeInput struct {
	// Delete If true, cascade delete all services owned by this global service
	Delete *bool `json:"delete,omitempty"`

	// Detach If true, immediately detach services from the database without draining
	Detach *bool `json:"detach,omitempty"`
}

// Catalog A catalog of PR automations for self-service deployment workflows
type Catalog struct {
	// Author Author or maintainer of the catalog
	Author *string `json:"author,omitempty"`

	// Category Category for organizing catalogs (e.g., infrastructure, applications)
	Category *string `json:"category,omitempty"`

	// DarkIcon URL or reference to the catalog's icon for dark mode
	DarkIcon *string `json:"dark_icon,omitempty"`

	// Description Description of the catalog's purpose and contents
	Description *string `json:"description,omitempty"`

	// Icon URL or reference to the catalog's icon for light mode
	Icon *string `json:"icon,omitempty"`

	// Id Unique identifier for the catalog
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// Name Name of the catalog
	Name *string `json:"name,omitempty"`

	// ProjectId ID of the project this catalog belongs to
	ProjectId *string    `json:"project_id,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// CatalogInput Input for creating or updating a catalog
type CatalogInput struct {
	// Author Author or maintainer of the catalog
	Author string `json:"author"`

	// Category Category for organizing the catalog
	Category *string `json:"category,omitempty"`

	// DarkIcon URL or reference to the catalog's icon for dark mode
	DarkIcon *string `json:"dark_icon,omitempty"`

	// Description Description of the catalog's purpose
	Description *string `json:"description,omitempty"`

	// Icon URL or reference to the catalog's icon for light mode
	Icon *string `json:"icon,omitempty"`

	// Name Name for the catalog
	Name string `json:"name"`

	// ProjectId ID of the project this catalog belongs to
	ProjectId *string `json:"project_id,omitempty"`
}

// Cluster A Kubernetes cluster that can be deployed to and managed through the platform
type Cluster struct {
	// AvailabilityZones The availability zones this cluster is running in
	AvailabilityZones *[]string `json:"availability_zones,omitempty"`

	// CpuTotal The total CPU capacity of the cluster in cores
	CpuTotal *float32 `json:"cpu_total,omitempty"`

	// CpuUtil The current CPU utilization of the cluster as a percentage
	CpuUtil *float32 `json:"cpu_util,omitempty"`

	// CurrentVersion Current Kubernetes version as reported by the deployment operator
	CurrentVersion *string `json:"current_version,omitempty"`

	// DeletedAt Timestamp when this cluster was scheduled for deletion
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Distro The distribution of kubernetes this cluster is running (generic, eks, aks, gke, rke, k3s, openshift)
	Distro *ClusterDistro `json:"distro,omitempty"`

	// Handle A short, unique human readable name used to identify this cluster
	Handle *string `json:"handle,omitempty"`

	// Id Unique identifier for the cluster
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// Installed Whether the deploy operator has been registered for this cluster
	Installed *bool `json:"installed,omitempty"`

	// KubeletVersion The lowest discovered kubelet version for all nodes in the cluster
	KubeletVersion *string `json:"kubelet_version,omitempty"`

	// MemoryTotal The total memory capacity of the cluster in bytes
	MemoryTotal *float32 `json:"memory_total,omitempty"`

	// MemoryUtil The current memory utilization of the cluster as a percentage
	MemoryUtil *float32 `json:"memory_util,omitempty"`

	// Metadata Arbitrary JSON metadata to store user-specific state of this cluster
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Human readable name of this cluster, will also translate to cloud k8s name
	Name *string `json:"name,omitempty"`

	// NamespaceCount The number of namespaces in this cluster
	NamespaceCount *int `json:"namespace_count,omitempty"`

	// NodeCount The number of nodes in this cluster
	NodeCount *int `json:"node_count,omitempty"`

	// OpenshiftVersion The version of OpenShift this cluster is running, if applicable
	OpenshiftVersion *string `json:"openshift_version,omitempty"`

	// PingedAt Timestamp of the last ping from the deploy operator
	PingedAt *time.Time `json:"pinged_at,omitempty"`

	// PodCount The number of pods in this cluster
	PodCount *int `json:"pod_count,omitempty"`

	// ProjectId ID of the project this cluster belongs to
	ProjectId *string `json:"project_id,omitempty"`

	// Protect If true, this cluster cannot be deleted
	Protect *bool `json:"protect,omitempty"`

	// Self Whether this is the management cluster itself
	Self *bool `json:"self,omitempty"`

	// Tags Key/value tags to filter and organize clusters
	Tags      *[]Tag     `json:"tags,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Version Desired Kubernetes version for the cluster
	Version *string `json:"version,omitempty"`

	// Virtual Whether this is a virtual cluster
	Virtual *bool `json:"virtual,omitempty"`
}

// ClusterDistro The distribution of kubernetes this cluster is running (generic, eks, aks, gke, rke, k3s, openshift)
type ClusterDistro string

// ClusterInput Input for creating or updating a cluster
type ClusterInput struct {
	// Handle A short, unique human readable name used to identify this cluster
	Handle *string `json:"handle,omitempty"`

	// Metadata Arbitrary JSON metadata to store user-specific state
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Human readable name for the cluster
	Name *string `json:"name,omitempty"`

	// ProjectId ID of the project this cluster belongs to
	ProjectId *string `json:"project_id,omitempty"`

	// Tags Key/value tags to filter and organize clusters
	Tags *[]TagInput `json:"tags,omitempty"`
}

// ClusterUpgrade An agentic workflow for upgrading a cluster
type ClusterUpgrade struct {
	// ClusterId ID of the cluster being upgraded
	ClusterId *string `json:"cluster_id,omitempty"`

	// Id Unique identifier for the cluster upgrade
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// Prompt Prompt used to generate the upgrade workflow
	Prompt *string `json:"prompt,omitempty"`

	// Runtime An agent runtime configured on a cluster for executing AI coding agents
	Runtime *AgentRuntime `json:"runtime,omitempty"`

	// RuntimeId ID of the agent runtime executing the upgrade
	RuntimeId *string `json:"runtime_id,omitempty"`

	// Status Status of the upgrade (pending, in_progress, completed, failed)
	Status *ClusterUpgradeStatus `json:"status,omitempty"`

	// Steps Steps that make up this upgrade workflow
	Steps     *[]ClusterUpgradeStep `json:"steps,omitempty"`
	UpdatedAt *time.Time            `json:"updated_at,omitempty"`

	// User A registed user
	User *User `json:"user,omitempty"`

	// UserId ID of the user who initiated the upgrade
	UserId *string `json:"user_id,omitempty"`

	// Version Target Kubernetes version for this upgrade
	Version *string `json:"version,omitempty"`
}

// ClusterUpgradeStatus Status of the upgrade (pending, in_progress, completed, failed)
type ClusterUpgradeStatus string

// ClusterUpgradeInput Input for creating a cluster upgrade workflow
type ClusterUpgradeInput struct {
	// Prompt Optional prompt to guide the upgrade workflow
	Prompt *string `json:"prompt,omitempty"`

	// RuntimeId Optional agent runtime ID to execute the upgrade
	RuntimeId *string `json:"runtime_id,omitempty"`
}

// ClusterUpgradeStep A step in an agentic cluster upgrade workflow
type ClusterUpgradeStep struct {
	// AgentRun An execution of an AI coding agent processing a prompt against a repository
	AgentRun *AgentRun `json:"agent_run,omitempty"`

	// AgentRunId ID of the agent run associated with this step, if any
	AgentRunId *string `json:"agent_run_id,omitempty"`

	// Error Error message if the step failed
	Error *string `json:"error,omitempty"`

	// Id Unique identifier for the upgrade step
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// Name Name of the upgrade step
	Name *string `json:"name,omitempty"`

	// Prompt Prompt used to generate the upgrade step
	Prompt *string `json:"prompt,omitempty"`

	// Status Status of the step (pending, in_progress, completed, failed)
	Status *ClusterUpgradeStepStatus `json:"status,omitempty"`

	// Type Type of step (addon, cloud_addon, infrastructure)
	Type      *ClusterUpgradeStepType `json:"type,omitempty"`
	UpdatedAt *time.Time              `json:"updated_at,omitempty"`

	// UpgradeId ID of the cluster upgrade this step belongs to
	UpgradeId *string `json:"upgrade_id,omitempty"`
}

// ClusterUpgradeStepStatus Status of the step (pending, in_progress, completed, failed)
type ClusterUpgradeStepStatus string

// ClusterUpgradeStepType Type of step (addon, cloud_addon, infrastructure)
type ClusterUpgradeStepType string

// ConsoleOpenAPIAIAgentRunList A paginated list of agent runs
type ConsoleOpenAPIAIAgentRunList struct {
	Data *[]AgentRun `json:"data,omitempty"`
}

// ConsoleOpenAPIAIAgentRuntimeList A paginated list of agent runtimes
type ConsoleOpenAPIAIAgentRuntimeList struct {
	Data *[]AgentRuntime `json:"data,omitempty"`
}

// ConsoleOpenAPIAIAgentSessionList A paginated list of agent sessions
type ConsoleOpenAPIAIAgentSessionList struct {
	Data *[]AgentSession `json:"data,omitempty"`
}

// ConsoleOpenAPIAISentinelList A paginated list of sentinels
type ConsoleOpenAPIAISentinelList struct {
	Data *[]Sentinel `json:"data,omitempty"`
}

// ConsoleOpenAPIAISentinelRunList A paginated list of sentinel runs
type ConsoleOpenAPIAISentinelRunList struct {
	Data *[]SentinelRun `json:"data,omitempty"`
}

// ConsoleOpenAPIAccessTokenScope A scope entry for an access token
type ConsoleOpenAPIAccessTokenScope struct {
	// Api A single API name
	Api *string `json:"api,omitempty"`

	// Apis API name
	Apis *[]string `json:"apis,omitempty"`

	// Identifier Identifier for scoped access
	Identifier *string `json:"identifier,omitempty"`

	// Ids Scoped resource ids
	Ids *[]string `json:"ids,omitempty"`
}

// ConsoleOpenAPICDClusterList A paginated list of clusters
type ConsoleOpenAPICDClusterList struct {
	Data *[]Cluster `json:"data,omitempty"`
}

// ConsoleOpenAPICDGitRepositoryList A list of git repositories
type ConsoleOpenAPICDGitRepositoryList struct {
	Data *[]GitRepository `json:"data,omitempty"`
}

// ConsoleOpenAPICDGlobalServiceList A paginated list of global services
type ConsoleOpenAPICDGlobalServiceList struct {
	Data *[]GlobalService `json:"data,omitempty"`
}

// ConsoleOpenAPICDHelmRepositoryList A list of helm repositories
type ConsoleOpenAPICDHelmRepositoryList struct {
	Data *[]HelmRepository `json:"data,omitempty"`
}

// ConsoleOpenAPICDPipelineList A paginated list of pipelines
type ConsoleOpenAPICDPipelineList struct {
	Data *[]Pipeline `json:"data,omitempty"`
}

// ConsoleOpenAPICDServiceList A paginated list of service deployments
type ConsoleOpenAPICDServiceList struct {
	Data *[]Service `json:"data,omitempty"`
}

// ConsoleOpenAPIProjectList A paginated list of projects
type ConsoleOpenAPIProjectList struct {
	Data *[]Project `json:"data,omitempty"`
}

// ConsoleOpenAPISCMCatalogList A paginated list of catalogs
type ConsoleOpenAPISCMCatalogList struct {
	Data *[]Catalog `json:"data,omitempty"`
}

// ConsoleOpenAPISCMConnectionGithubApp A Github App connection
type ConsoleOpenAPISCMConnectionGithubApp struct {
	// AppId The Github App ID
	AppId *string `json:"app_id,omitempty"`

	// InstallationId The Github App installation ID
	InstallationId *string `json:"installation_id,omitempty"`
}

// ConsoleOpenAPISCMConnectionList A list of SCM connections
type ConsoleOpenAPISCMConnectionList struct {
	Data *[]ScmConnection `json:"data,omitempty"`
}

// ConsoleOpenAPISCMPrAutomationList A paginated list of PR automations
type ConsoleOpenAPISCMPrAutomationList struct {
	Data *[]PrAutomation `json:"data,omitempty"`
}

// ConsoleOpenAPISCMPullRequestList A paginated list of pull requests
type ConsoleOpenAPISCMPullRequestList struct {
	Data *[]PullRequest `json:"data,omitempty"`
}

// ConsoleOpenAPIStackList A list of stacks
type ConsoleOpenAPIStackList struct {
	Data *[]Stack `json:"data,omitempty"`
}

// ConsoleOpenAPIUserList A list of users
type ConsoleOpenAPIUserList struct {
	Data *[]User `json:"data,omitempty"`
}

// ConsoleOpenAPIUserRoles The roles of the user
type ConsoleOpenAPIUserRoles struct {
	Admin bool `json:"admin"`
}

// CreatePullRequestInput Input for creating a pull request using a PR automation
type CreatePullRequestInput struct {
	// Branch Branch name for the pull request (overrides default)
	Branch *string `json:"branch,omitempty"`

	// Context Context variables to pass to the PR automation templates
	Context map[string]interface{} `json:"context"`

	// Identifier Repository identifier (overrides default)
	Identifier *string `json:"identifier,omitempty"`
}

// Git Git reference configuration
type Git struct {
	Folder *string `json:"folder,omitempty"`
	Ref    *string `json:"ref,omitempty"`
}

// GitRepository A git repository
type GitRepository struct {
	AuthMethod *GitRepositoryAuthMethod `json:"auth_method,omitempty"`

	// Error The error message for the git repository's last pull attempt
	Error  *string              `json:"error,omitempty"`
	Health *GitRepositoryHealth `json:"health,omitempty"`

	// HttpsPath The https url for this git repo if you need to customize it
	HttpsPath  *string    `json:"https_path,omitempty"`
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// PulledAt The last successful git pull timestamp
	PulledAt  *time.Time `json:"pulled_at,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Url The url of the git repository, can be either an https or ssh url
	Url *string `json:"url,omitempty"`

	// UrlFormat A format string to get the http url for a subfolder in a git repo
	UrlFormat *string `json:"url_format,omitempty"`
}

// GitRepositoryAuthMethod defines model for GitRepository.AuthMethod.
type GitRepositoryAuthMethod string

// GitRepositoryHealth defines model for GitRepository.Health.
type GitRepositoryHealth string

// GitRepositoryInput Input for creating or updating a git repository
type GitRepositoryInput struct {
	// ConnectionId The id of the scm connection to use for authentication
	ConnectionId *string `json:"connection_id,omitempty"`

	// Passphrase A passphrase to decrypt the given private key
	Passphrase *string `json:"passphrase,omitempty"`

	// Password The http password for http authenticated repos
	Password *string `json:"password,omitempty"`

	// PrivateKey An ssh private key to use with this repo if an ssh url was given
	PrivateKey *string `json:"private_key,omitempty"`

	// Url The url of the git repository, can be either an https or ssh url
	Url string `json:"url"`

	// Username The http username for authenticated http repos, defaults to apiKey for github
	Username *string `json:"username,omitempty"`
}

// GithubAppInput Github App authentication configuration
type GithubAppInput struct {
	// AppId The GitHub App ID
	AppId string `json:"app_id"`

	// InstallationId The GitHub App installation ID
	InstallationId string `json:"installation_id"`

	// PrivateKey The private key for the GitHub App
	PrivateKey string `json:"private_key"`
}

// GlobalService A global service that deploys services across clusters matching specified criteria
type GlobalService struct {
	// Cascade Cascade behavior when the global service is deleted
	Cascade *Cascade `json:"cascade,omitempty"`

	// Distro Target cluster distribution (e.g., eks, aks, gke, generic)
	Distro *GlobalServiceDistro `json:"distro,omitempty"`

	// Id Unique identifier for the global service
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// Interval Polling interval for syncing the global service (e.g., "5m", "1h")
	Interval *string `json:"interval,omitempty"`

	// Mgmt If true, the global service will target the management cluster
	Mgmt *bool `json:"mgmt,omitempty"`

	// Name Name of the global service
	Name *string `json:"name,omitempty"`

	// ProjectId ID of the project this global service belongs to
	ProjectId *string `json:"project_id,omitempty"`

	// ProviderId ID of the cluster provider to filter target clusters
	ProviderId *string `json:"provider_id,omitempty"`

	// Reparent If true, allows reparenting of existing services owned by this global service
	Reparent *bool `json:"reparent,omitempty"`

	// ServiceId ID of the source service to clone (mutually exclusive with template)
	ServiceId *string `json:"service_id,omitempty"`

	// Tags Tags used to match target clusters
	Tags *[]Tag `json:"tags,omitempty"`

	// Template A service template that defines how services are created from a global service
	Template  *ServiceTemplate `json:"template,omitempty"`
	UpdatedAt *time.Time       `json:"updated_at,omitempty"`
}

// GlobalServiceDistro Target cluster distribution (e.g., eks, aks, gke, generic)
type GlobalServiceDistro string

// GlobalServiceInput Input for creating or updating a global service
type GlobalServiceInput struct {
	// Cascade Input for cascade behavior when the global service is deleted
	Cascade *CascadeInput `json:"cascade,omitempty"`

	// Distro Target cluster distribution
	Distro *GlobalServiceInputDistro `json:"distro,omitempty"`

	// Interval Polling interval for syncing (e.g., "5m", "1h")
	Interval *string `json:"interval,omitempty"`

	// Mgmt If true, target the management cluster
	Mgmt *bool `json:"mgmt,omitempty"`

	// Name Name for the global service
	Name string `json:"name"`

	// ProjectId ID of the project this global service belongs to
	ProjectId *string `json:"project_id,omitempty"`

	// ProviderId ID of the cluster provider to filter target clusters
	ProviderId *string `json:"provider_id,omitempty"`

	// Reparent If true, allows reparenting of existing services
	Reparent *bool `json:"reparent,omitempty"`

	// Tags Tags used to match target clusters
	Tags *[]TagInput `json:"tags,omitempty"`

	// Template Input for a service template configuration
	Template *ServiceTemplateInput `json:"template,omitempty"`
}

// GlobalServiceInputDistro Target cluster distribution
type GlobalServiceInputDistro string

// HelmRepository A helm repository
type HelmRepository struct {
	// Error The error message for the helm repository's last pull attempt
	Error      *string                 `json:"error,omitempty"`
	Health     *HelmRepositoryHealth   `json:"health,omitempty"`
	Id         *string                 `json:"id,omitempty"`
	InsertedAt *time.Time              `json:"inserted_at,omitempty"`
	Provider   *HelmRepositoryProvider `json:"provider,omitempty"`

	// PulledAt The last successful pull timestamp
	PulledAt  *time.Time `json:"pulled_at,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Url The url of the helm repository
	Url *string `json:"url,omitempty"`
}

// HelmRepositoryHealth defines model for HelmRepository.Health.
type HelmRepositoryHealth string

// HelmRepositoryProvider defines model for HelmRepository.Provider.
type HelmRepositoryProvider string

// HelmRepositoryInput Input for upserting a helm repository
type HelmRepositoryInput struct {
	// Auth Authentication configuration for the helm repository
	Auth *struct {
		// Aws AWS credentials for ECR
		Aws *struct {
			// AccessKey AWS access key ID
			AccessKey *string `json:"access_key,omitempty"`

			// AssumeRoleArn ARN of the role to assume
			AssumeRoleArn *string `json:"assume_role_arn,omitempty"`

			// SecretAccessKey AWS secret access key
			SecretAccessKey *string `json:"secret_access_key,omitempty"`
		} `json:"aws,omitempty"`

		// Azure Azure credentials for ACR
		Azure *struct {
			// ClientId Azure client ID
			ClientId *string `json:"client_id,omitempty"`

			// ClientSecret Azure client secret
			ClientSecret *string `json:"client_secret,omitempty"`

			// SubscriptionId Azure subscription ID
			SubscriptionId *string `json:"subscription_id,omitempty"`

			// TenantId Azure tenant ID
			TenantId *string `json:"tenant_id,omitempty"`
		} `json:"azure,omitempty"`

		// Basic Basic auth credentials
		Basic *struct {
			// Password The password for basic auth
			Password *string `json:"password,omitempty"`

			// Username The username for basic auth
			Username *string `json:"username,omitempty"`
		} `json:"basic,omitempty"`

		// Bearer Bearer token auth
		Bearer *struct {
			// Token The bearer token
			Token *string `json:"token,omitempty"`
		} `json:"bearer,omitempty"`

		// Gcp GCP credentials for GCR/Artifact Registry
		Gcp *struct {
			// ApplicationCredentials GCP service account JSON credentials
			ApplicationCredentials *string `json:"application_credentials,omitempty"`
		} `json:"gcp,omitempty"`
	} `json:"auth,omitempty"`
	Provider *HelmRepositoryInputProvider `json:"provider,omitempty"`

	// Url The url of the helm repository
	Url *string `json:"url,omitempty"`
}

// HelmRepositoryInputProvider defines model for HelmRepositoryInput.Provider.
type HelmRepositoryInputProvider string

// HelmSpec Helm chart configuration for a service
type HelmSpec struct {
	// Chart Helm chart name (e.g., "nginx")
	Chart *string `json:"chart,omitempty"`

	// Release Helm release name for the deployment
	Release *string `json:"release,omitempty"`

	// RepositoryId ID of the Helm repository for this chart
	RepositoryId *string `json:"repository_id,omitempty"`

	// Url URL of the Helm chart repository
	Url *string `json:"url,omitempty"`

	// Values Inline helm values for the helm chart
	Values *string `json:"values,omitempty"`

	// ValuesFiles List of referenced values.yaml files
	ValuesFiles *[]string `json:"values_files,omitempty"`

	// Version Helm chart version
	Version *string `json:"version,omitempty"`
}

// HelmSpecInput Helm chart configuration input
type HelmSpecInput struct {
	// Chart Name of the Helm chart to deploy
	Chart *string `json:"chart,omitempty"`

	// Release Desired Helm release name
	Release *string `json:"release,omitempty"`

	// RepositoryId ID of a GitRepository to use for sourcing this helm chart
	RepositoryId *string `json:"repository_id,omitempty"`

	// Url Helm chart repository URL
	Url *string `json:"url,omitempty"`

	// Values YAML configuration values for the Helm chart
	Values *string `json:"values,omitempty"`

	// ValuesFiles List of referenced values.yaml files to be used with the chart
	ValuesFiles *[]string `json:"values_files,omitempty"`

	// Version Version of the Helm chart
	Version *string `json:"version,omitempty"`
}

// Kustomize Kustomize configuration for a service
type Kustomize struct {
	// EnableHelm If true, Helm integration is enabled for Kustomize
	EnableHelm *bool `json:"enable_helm,omitempty"`

	// Path Path to the kustomization.yaml or kustomize directory relative to the repository root
	Path *string `json:"path,omitempty"`
}

// KustomizeInput Kustomize configuration input
type KustomizeInput struct {
	// EnableHelm Enable Helm support within Kustomize if true
	EnableHelm *bool `json:"enable_helm,omitempty"`

	// Path Path to the kustomization.yaml or kustomize directory
	Path *string `json:"path,omitempty"`
}

// Pipeline A continuous deployment pipeline that orchestrates service promotions through stages
type Pipeline struct {
	// Edges Edges connecting stages with promotion gates
	Edges *[]PipelineEdge `json:"edges,omitempty"`

	// Id Unique identifier for the pipeline
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// Name Name of the pipeline
	Name *string `json:"name,omitempty"`

	// ProjectId ID of the project this pipeline belongs to
	ProjectId *string `json:"project_id,omitempty"`

	// Stages Ordered list of stages in this pipeline
	Stages    *[]PipelineStage `json:"stages,omitempty"`
	UpdatedAt *time.Time       `json:"updated_at,omitempty"`
}

// PipelineContext A context containing data for pipeline promotions and PR automations
type PipelineContext struct {
	// Context Arbitrary key-value data map passed through the pipeline
	Context *map[string]interface{} `json:"context,omitempty"`

	// Id Unique identifier for the context
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// PipelineId ID of the pipeline this context belongs to
	PipelineId *string    `json:"pipeline_id,omitempty"`
	UpdatedAt  *time.Time `json:"updated_at,omitempty"`
}

// PipelineContextInput Input for creating a new pipeline context to trigger a pipeline run
type PipelineContextInput struct {
	// Context Arbitrary key-value data map to pass through the pipeline for PR automations
	Context map[string]interface{} `json:"context"`
}

// PipelineEdge An edge connecting two stages with optional promotion gates
type PipelineEdge struct {
	// FromId ID of the source stage
	FromId *string `json:"from_id,omitempty"`

	// Gates Gates that must be satisfied for promotion
	Gates *[]PipelineGate `json:"gates,omitempty"`

	// Id Unique identifier for the edge
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// PromotedAt Timestamp when promotion last occurred through this edge
	PromotedAt *time.Time `json:"promoted_at,omitempty"`

	// ToId ID of the destination stage
	ToId      *string    `json:"to_id,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// PipelineGate A gate checkpoint for pipeline promotions
type PipelineGate struct {
	// Id Unique identifier for the gate
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// Name Name of the gate
	Name *string `json:"name,omitempty"`

	// State Current state of the gate (pending, open, closed, running)
	State *PipelineGateState `json:"state,omitempty"`

	// Type Type of gate (approval, window, job)
	Type      *PipelineGateType `json:"type,omitempty"`
	UpdatedAt *time.Time        `json:"updated_at,omitempty"`
}

// PipelineGateState Current state of the gate (pending, open, closed, running)
type PipelineGateState string

// PipelineGateType Type of gate (approval, window, job)
type PipelineGateType string

// PipelineStage A stage in the pipeline representing a deployment environment
type PipelineStage struct {
	// Id Unique identifier for the stage
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// Name Name of the stage (e.g., dev, staging, production)
	Name *string `json:"name,omitempty"`

	// Services Services deployed in this stage
	Services  *[]StageService `json:"services,omitempty"`
	UpdatedAt *time.Time      `json:"updated_at,omitempty"`
}

// PrAutomation A PR automation template for creating infrastructure or application pull requests
type PrAutomation struct {
	// Addon Name of the addon this PR automation is associated with, if any
	Addon *string `json:"addon,omitempty"`

	// Branch Default branch name for generated pull requests
	Branch *string `json:"branch,omitempty"`

	// CatalogId ID of the catalog this PR automation belongs to
	CatalogId *string `json:"catalog_id,omitempty"`

	// ClusterId ID of the cluster this PR automation is associated with, if any
	ClusterId *string `json:"cluster_id,omitempty"`

	// Configuration Configuration fields for the PR automation
	Configuration *[]PrConfiguration `json:"configuration,omitempty"`

	// ConnectionId ID of the SCM connection used for creating pull requests
	ConnectionId *string `json:"connection_id,omitempty"`

	// DarkIcon URL or reference to the PR automation's icon for dark mode
	DarkIcon *string `json:"dark_icon,omitempty"`

	// Documentation Documentation describing the PR automation's purpose and usage
	Documentation *string `json:"documentation,omitempty"`

	// Icon URL or reference to the PR automation's icon for light mode
	Icon *string `json:"icon,omitempty"`

	// Id Unique identifier for the PR automation
	Id *string `json:"id,omitempty"`

	// Identifier Repository identifier (e.g., owner/repo) for the PR automation
	Identifier *string    `json:"identifier,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// Message Message/body template for generated pull requests
	Message *string `json:"message,omitempty"`

	// Name Name of the PR automation
	Name *string `json:"name,omitempty"`

	// ProjectId ID of the project this PR automation belongs to
	ProjectId *string `json:"project_id,omitempty"`

	// ServiceId ID of the service this PR automation is associated with, if any
	ServiceId *string `json:"service_id,omitempty"`

	// Title Title template for generated pull requests
	Title     *string    `json:"title,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// PrConfiguration A configuration field for a PR automation
type PrConfiguration struct {
	// Default Default value for the configuration field
	Default *string `json:"default,omitempty"`

	// Documentation Documentation describing the configuration field
	Documentation *string `json:"documentation,omitempty"`

	// Longform Extended documentation for the configuration field
	Longform *string `json:"longform,omitempty"`

	// Name Name of the configuration field
	Name *string `json:"name,omitempty"`

	// Optional Whether the configuration field is optional
	Optional *bool `json:"optional,omitempty"`

	// Placeholder Placeholder text for the configuration field input
	Placeholder *string `json:"placeholder,omitempty"`

	// Type Type of the configuration field (string, int, bool, domain, file, function, enum, password)
	Type *PrConfigurationType `json:"type,omitempty"`

	// Validation Validation rules for a configuration field
	Validation *PrConfigurationValidation `json:"validation,omitempty"`
}

// PrConfigurationType Type of the configuration field (string, int, bool, domain, file, function, enum, password)
type PrConfigurationType string

// PrConfigurationValidation Validation rules for a configuration field
type PrConfigurationValidation struct {
	// Message Error message to display when validation fails
	Message *string `json:"message,omitempty"`

	// Regex Regular expression pattern for validation
	Regex *string `json:"regex,omitempty"`
}

// Project A project is a top-level organizational unit that groups related resources such as clusters, stacks, pipelines, and services
type Project struct {
	// Default Whether this is the default project for the instance
	Default *bool `json:"default,omitempty"`

	// Description A human-readable description of the project
	Description *string `json:"description,omitempty"`

	// Id The unique identifier of the project
	Id         *openapi_types.UUID `json:"id,omitempty"`
	InsertedAt *time.Time          `json:"inserted_at,omitempty"`

	// Name The name of the project
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// PromotionCriteria Criteria for promoting a service to the next stage
type PromotionCriteria struct {
	// Id Unique identifier for the promotion criteria
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// PrAutomationId ID of the PR automation to trigger on promotion
	PrAutomationId *string `json:"pr_automation_id,omitempty"`

	// Repository Repository to create PRs against for promotion
	Repository *string    `json:"repository,omitempty"`
	UpdatedAt  *time.Time `json:"updated_at,omitempty"`
}

// PullRequest A pull request reference tracked by the platform for deployment workflows
type PullRequest struct {
	// Body Body/description of the pull request
	Body *string `json:"body,omitempty"`

	// ClusterId ID of the cluster this pull request is associated with, if any
	ClusterId *string `json:"cluster_id,omitempty"`

	// Creator Username of the pull request creator in the source control provider
	Creator *string `json:"creator,omitempty"`

	// Id Unique identifier for the pull request record
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// Labels Labels applied to the pull request
	Labels *[]string `json:"labels,omitempty"`

	// Ref Git ref (branch name) for the pull request
	Ref *string `json:"ref,omitempty"`

	// ServiceId ID of the service this pull request is associated with, if any
	ServiceId *string `json:"service_id,omitempty"`

	// Sha Git SHA of the pull request head
	Sha *string `json:"sha,omitempty"`

	// StackId ID of the stack this pull request is associated with, if any
	StackId *string `json:"stack_id,omitempty"`

	// Status Current status of the pull request (open, merged, closed)
	Status *PullRequestStatus `json:"status,omitempty"`

	// Title Title of the pull request
	Title     *string    `json:"title,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Url URL of the pull request in the source control provider
	Url *string `json:"url,omitempty"`
}

// PullRequestStatus Current status of the pull request (open, merged, closed)
type PullRequestStatus string

// RendererHelm Helm-specific configuration for a renderer
type RendererHelm struct {
	// IgnoreHooks Whether to ignore Helm hooks when rendering
	IgnoreHooks *bool `json:"ignore_hooks,omitempty"`

	// Release Helm release name to use when rendering
	Release *string `json:"release,omitempty"`

	// Values Helm values file content to use when rendering
	Values *string `json:"values,omitempty"`

	// ValuesFiles List of relative paths to values files
	ValuesFiles *[]string `json:"values_files,omitempty"`
}

// RendererHelmInput Helm-specific configuration input for a renderer
type RendererHelmInput struct {
	// IgnoreHooks Whether to ignore Helm hooks when rendering
	IgnoreHooks *bool `json:"ignore_hooks,omitempty"`

	// Release Helm release name to use when rendering
	Release *string `json:"release,omitempty"`

	// Values Helm values file content to use when rendering
	Values *string `json:"values,omitempty"`

	// ValuesFiles List of relative paths to values files
	ValuesFiles *[]string `json:"values_files,omitempty"`
}

// ScmConnection An SCM connection for integrating with source control providers
type ScmConnection struct {
	// ApiUrl Base URL for HTTP APIs for self-hosted versions if different from base URL
	ApiUrl *string `json:"api_url,omitempty"`

	// BaseUrl Base URL for self-hosted versions of this provider
	BaseUrl *string `json:"base_url,omitempty"`

	// Default Whether this is the default SCM connection
	Default *bool `json:"default,omitempty"`

	// Github A Github App connection
	Github     *ConsoleOpenAPISCMConnectionGithubApp `json:"github,omitempty"`
	Id         *string                               `json:"id,omitempty"`
	InsertedAt *time.Time                            `json:"inserted_at,omitempty"`

	// Name The name of the SCM connection
	Name      string            `json:"name"`
	Type      ScmConnectionType `json:"type"`
	UpdatedAt *time.Time        `json:"updated_at,omitempty"`

	// Username The username for authentication
	Username *string `json:"username,omitempty"`
}

// ScmConnectionType defines model for ScmConnection.Type.
type ScmConnectionType string

// ScmConnectionInput Input for creating or updating an SCM connection
type ScmConnectionInput struct {
	// ApiUrl Base URL for HTTP APIs for self-hosted versions if different from base URL
	ApiUrl *string `json:"api_url,omitempty"`

	// BaseUrl Base URL for Git clones for self-hosted versions
	BaseUrl *string `json:"base_url,omitempty"`

	// Default Whether this is the default SCM connection
	Default *bool `json:"default,omitempty"`

	// Github Github App authentication configuration
	Github *GithubAppInput `json:"github,omitempty"`

	// Name The name of the SCM connection
	Name string `json:"name"`

	// SigningPrivateKey A private key used for signing commits
	SigningPrivateKey *string `json:"signing_private_key,omitempty"`

	// Token The access token for authentication
	Token *string                `json:"token,omitempty"`
	Type  ScmConnectionInputType `json:"type"`

	// Username The username for authentication
	Username *string `json:"username,omitempty"`
}

// ScmConnectionInputType defines model for ScmConnectionInput.Type.
type ScmConnectionInputType string

// Sentinel An automated monitoring system that runs checks against your infrastructure
type Sentinel struct {
	// Checks List of checks configured for this sentinel
	Checks *[]SentinelCheck `json:"checks,omitempty"`

	// Description Description of what this sentinel monitors
	Description *string `json:"description,omitempty"`

	// Id Unique identifier for the sentinel
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// LastRunAt Timestamp of when this sentinel was last executed
	LastRunAt *time.Time `json:"last_run_at,omitempty"`

	// Name Human-readable name of this sentinel
	Name *string `json:"name,omitempty"`

	// ProjectId ID of the project this sentinel belongs to
	ProjectId *string `json:"project_id,omitempty"`

	// RepositoryId ID of the git repository for rule files
	RepositoryId *string `json:"repository_id,omitempty"`

	// Status Status of the sentinel's last run (pending, success, failed)
	Status    *SentinelStatus `json:"status,omitempty"`
	UpdatedAt *time.Time      `json:"updated_at,omitempty"`
}

// SentinelStatus Status of the sentinel's last run (pending, success, failed)
type SentinelStatus string

// SentinelCheck A specific monitoring check within a sentinel
type SentinelCheck struct {
	// Id Unique identifier for the check
	Id *string `json:"id,omitempty"`

	// Name Name of this check
	Name *string `json:"name,omitempty"`

	// RuleFile Path to the rule file for this check within the repository
	RuleFile *string `json:"rule_file,omitempty"`

	// Type Type of check (log, kubernetes, integration_test)
	Type *SentinelCheckType `json:"type,omitempty"`
}

// SentinelCheckType Type of check (log, kubernetes, integration_test)
type SentinelCheckType string

// SentinelCheckResult The result of a single check within a sentinel run
type SentinelCheckResult struct {
	// FailedCount Number of failed jobs
	FailedCount *int `json:"failed_count,omitempty"`

	// JobCount Total number of jobs spawned for this check
	JobCount *int `json:"job_count,omitempty"`

	// Name Name of the check that was executed
	Name *string `json:"name,omitempty"`

	// Reason Reason for failure if the check failed
	Reason *string `json:"reason,omitempty"`

	// Status Status of this check (pending, success, failed)
	Status *SentinelCheckResultStatus `json:"status,omitempty"`

	// SuccessfulCount Number of successful jobs
	SuccessfulCount *int `json:"successful_count,omitempty"`
}

// SentinelCheckResultStatus Status of this check (pending, success, failed)
type SentinelCheckResultStatus string

// SentinelRun A single execution of a sentinel's monitoring checks
type SentinelRun struct {
	// CompletedAt Timestamp when the run completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// Id Unique identifier for the sentinel run
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// Jobs Jobs spawned by this sentinel run for integration tests
	Jobs *[]SentinelRunJob `json:"jobs,omitempty"`

	// Results Results of individual checks in this run
	Results *[]SentinelCheckResult `json:"results,omitempty"`

	// SentinelId ID of the sentinel that was executed
	SentinelId *string `json:"sentinel_id,omitempty"`

	// Status Current status of the run (pending, success, failed)
	Status    *SentinelRunStatus `json:"status,omitempty"`
	UpdatedAt *time.Time         `json:"updated_at,omitempty"`
}

// SentinelRunStatus Current status of the run (pending, success, failed)
type SentinelRunStatus string

// SentinelRunJob An integration test job spawned by a sentinel run
type SentinelRunJob struct {
	// Check Name of the check this job belongs to
	Check *string `json:"check,omitempty"`

	// ClusterId ID of the cluster this job ran on
	ClusterId *string `json:"cluster_id,omitempty"`

	// CompletedAt Timestamp when the job completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// Format Output format of the job (plaintext, junit)
	Format *SentinelRunJobFormat `json:"format,omitempty"`

	// Id Unique identifier for the job
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// Output Output produced by the job
	Output *string `json:"output,omitempty"`

	// RepositoryId ID of the git repository used for the test
	RepositoryId *string `json:"repository_id,omitempty"`

	// SentinelRunId ID of the sentinel run this job belongs to
	SentinelRunId *string `json:"sentinel_run_id,omitempty"`

	// Status Current status of the job (pending, running, success, failed)
	Status    *SentinelRunJobStatus `json:"status,omitempty"`
	UpdatedAt *time.Time            `json:"updated_at,omitempty"`
}

// SentinelRunJobFormat Output format of the job (plaintext, junit)
type SentinelRunJobFormat string

// SentinelRunJobStatus Current status of the job (pending, running, success, failed)
type SentinelRunJobStatus string

// Service A service deployment reference deployed from a git repo into a cluster
type Service struct {
	// ClusterId ID of the cluster this service is deployed to
	ClusterId *string `json:"cluster_id,omitempty"`

	// ComponentStatus Status message from components (e.g. unhealthy reason)
	ComponentStatus *string `json:"component_status,omitempty"`

	// DeletedAt Timestamp the service was marked for deletion, if deleted
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// DryRun If true, this service is running in dry-run mode
	DryRun *bool `json:"dry_run,omitempty"`

	// Errors List of errors generated by the deployment operator
	Errors *[]ServiceError `json:"errors,omitempty"`

	// Git Git reference configuration
	Git *Git `json:"git,omitempty"`

	// Helm Helm chart configuration for a service
	Helm *HelmSpec `json:"helm,omitempty"`

	// Id Unique identifier for the service deployment
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// Interval Polling interval for the service reconcile loop (e.g., "5m")
	Interval *string `json:"interval,omitempty"`

	// Kustomize Kustomize configuration for a service
	Kustomize *Kustomize `json:"kustomize,omitempty"`

	// Message Latest commit message from the synced revision
	Message *string `json:"message,omitempty"`

	// Name Name of the service
	Name *string `json:"name,omitempty"`

	// Namespace Kubernetes namespace where the service is deployed
	Namespace *string `json:"namespace,omitempty"`

	// Protect If true, prevents service deletion or config edits
	Protect *bool `json:"protect,omitempty"`

	// Renderers Custom renderers for processing service manifests
	Renderers *[]ServiceRenderer `json:"renderers,omitempty"`

	// RepositoryId ID of the git or Helm repository backing this service
	RepositoryId *string `json:"repository_id,omitempty"`

	// Sha Git commit SHA for the current synced revision.  This will be a helm digest if a pure helm chart as well
	Sha *string `json:"sha,omitempty"`

	// Sources Additional source repositories for this service
	Sources *[]ServiceSource `json:"sources,omitempty"`

	// Status Current status of the service deployment (e.g., stale, synced, healthy, failed, paused)
	Status *ServiceStatus `json:"status,omitempty"`

	// Templated If true, the service was deployed using a template
	Templated *bool      `json:"templated,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ServiceStatus Current status of the service deployment (e.g., stale, synced, healthy, failed, paused)
type ServiceStatus string

// ServiceConfigurationInput A configuration key-value pair for a service deployment. These are used as templating values when rendering service manifests.
type ServiceConfigurationInput struct {
	// Name The name/key of the configuration value
	Name string `json:"name"`

	// Value The value for this configuration key. If null, will remove this value
	Value *string `json:"value,omitempty"`
}

// ServiceError An error reported by the deployment operator during service sync
type ServiceError struct {
	// Message Error message describing what went wrong
	Message *string `json:"message,omitempty"`

	// Source Source of the error (e.g., component name or sync stage)
	Source *string `json:"source,omitempty"`

	// Warning If true, this is a warning rather than a fatal error
	Warning *bool `json:"warning,omitempty"`
}

// ServiceInput Input for creating or updating a service deployment
type ServiceInput struct {
	// Configuration Configuration values to template into the service manifests. You must pass the full list of configuration inputs
	Configuration *[]ServiceConfigurationInput `json:"configuration,omitempty"`

	// DryRun If true, does not actually apply any changes to the cluster
	DryRun *bool `json:"dry_run,omitempty"`

	// Git Git reference configuration
	Git *Git `json:"git,omitempty"`

	// Helm Helm chart configuration input
	Helm *HelmSpecInput `json:"helm,omitempty"`

	// Kustomize Kustomize configuration input
	Kustomize *KustomizeInput `json:"kustomize,omitempty"`

	// Name Desired name for the service
	Name string `json:"name"`

	// Namespace Target deployment namespace
	Namespace string `json:"namespace"`

	// Protect If true, marks the service as protected from accidental changes
	Protect *bool `json:"protect,omitempty"`

	// Renderers Custom renderers for processing service manifests
	Renderers *[]ServiceRendererInput `json:"renderers,omitempty"`

	// RepositoryId ID of the backing repository for this service
	RepositoryId *string `json:"repository_id,omitempty"`

	// Sources Additional source repositories for this service
	Sources *[]ServiceSourceInput `json:"sources,omitempty"`
}

// ServiceRenderer A custom renderer for processing service manifests at a specific path
type ServiceRenderer struct {
	// Helm Helm-specific configuration for a renderer
	Helm *RendererHelm `json:"helm,omitempty"`

	// Path Path within the repository where this renderer applies
	Path *string `json:"path,omitempty"`

	// Type Type of renderer (auto, raw, helm, kustomize)
	Type *ServiceRendererType `json:"type,omitempty"`
}

// ServiceRendererType Type of renderer (auto, raw, helm, kustomize)
type ServiceRendererType string

// ServiceRendererInput Input for a custom renderer configuration
type ServiceRendererInput struct {
	// Helm Helm-specific configuration input for a renderer
	Helm *RendererHelmInput `json:"helm,omitempty"`

	// Path Path within the repository where this renderer applies
	Path string `json:"path"`

	// Type Type of renderer (auto, raw, helm, kustomize)
	Type ServiceRendererInputType `json:"type"`
}

// ServiceRendererInputType Type of renderer (auto, raw, helm, kustomize)
type ServiceRendererInputType string

// ServiceSource An additional source repository for a service deployment
type ServiceSource struct {
	// Git Git reference configuration
	Git *Git `json:"git,omitempty"`

	// Path Subdirectory path where this source will live in the final tarball
	Path *string `json:"path,omitempty"`

	// RepositoryId ID of the git repository to source from
	RepositoryId *string `json:"repository_id,omitempty"`
}

// ServiceSourceInput Input for an additional source repository
type ServiceSourceInput struct {
	// Git Git reference configuration
	Git *Git `json:"git,omitempty"`

	// Path Subdirectory path where this source will live in the final tarball
	Path *string `json:"path,omitempty"`

	// RepositoryId ID of the git repository to source from
	RepositoryId *string `json:"repository_id,omitempty"`
}

// ServiceTemplate A service template that defines how services are created from a global service
type ServiceTemplate struct {
	// Contexts List of service context names to include
	Contexts *[]string `json:"contexts,omitempty"`

	// Git Git reference configuration
	Git *Git `json:"git,omitempty"`

	// Helm Helm chart configuration for a service
	Helm *HelmSpec `json:"helm,omitempty"`

	// Id Unique identifier for the service template
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// Kustomize Kustomize configuration for a service
	Kustomize *Kustomize `json:"kustomize,omitempty"`

	// Name Name of the service to be created from this template
	Name *string `json:"name,omitempty"`

	// Namespace Kubernetes namespace for the service
	Namespace *string `json:"namespace,omitempty"`

	// Protect If true, prevents accidental deletion or modification of created services
	Protect *bool `json:"protect,omitempty"`

	// RepositoryId ID of the git repository backing this template
	RepositoryId *string `json:"repository_id,omitempty"`

	// Templated If true, the service configuration supports variable interpolation
	Templated *bool      `json:"templated,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ServiceTemplateInput Input for a service template configuration
type ServiceTemplateInput struct {
	// Contexts List of service context names to include
	Contexts *[]string `json:"contexts,omitempty"`

	// Git Git reference configuration
	Git *Git `json:"git,omitempty"`

	// Helm Helm chart configuration input
	Helm *HelmSpecInput `json:"helm,omitempty"`

	// Kustomize Kustomize configuration input
	Kustomize *KustomizeInput `json:"kustomize,omitempty"`

	// Name Name of the service to be created from this template
	Name string `json:"name"`

	// Namespace Kubernetes namespace for the service
	Namespace string `json:"namespace"`

	// Protect If true, prevent accidental deletion or modification
	Protect *bool `json:"protect,omitempty"`

	// RepositoryId ID of the git repository backing this template
	RepositoryId *string `json:"repository_id,omitempty"`

	// Templated If true, enable variable interpolation in service configuration
	Templated *bool `json:"templated,omitempty"`
}

// Stack An infrastructure stack
type Stack struct {
	Approval  *bool      `json:"approval,omitempty"`
	ClusterId *string    `json:"cluster_id,omitempty"`
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Git Git reference configuration
	Git          *Git         `json:"git,omitempty"`
	Id           *string      `json:"id,omitempty"`
	InsertedAt   *time.Time   `json:"inserted_at,omitempty"`
	Interval     *string      `json:"interval,omitempty"`
	ManageState  *bool        `json:"manage_state,omitempty"`
	Name         *string      `json:"name,omitempty"`
	Paused       *bool        `json:"paused,omitempty"`
	ProjectId    *string      `json:"project_id,omitempty"`
	RepositoryId *string      `json:"repository_id,omitempty"`
	Status       *StackStatus `json:"status,omitempty"`
	Tags         *[]Tag       `json:"tags,omitempty"`
	Type         *StackType   `json:"type,omitempty"`
	UpdatedAt    *time.Time   `json:"updated_at,omitempty"`
	Workdir      *string      `json:"workdir,omitempty"`
}

// StackStatus defines model for Stack.Status.
type StackStatus string

// StackType defines model for Stack.Type.
type StackType string

// StackInput An infrastructure stack input
type StackInput struct {
	Approval  *bool   `json:"approval,omitempty"`
	ClusterId *string `json:"cluster_id,omitempty"`

	// Git Git reference configuration
	Git          *Git            `json:"git,omitempty"`
	Interval     *string         `json:"interval,omitempty"`
	ManageState  *bool           `json:"manage_state,omitempty"`
	Name         *string         `json:"name,omitempty"`
	Paused       *bool           `json:"paused,omitempty"`
	ProjectId    *string         `json:"project_id,omitempty"`
	RepositoryId *string         `json:"repository_id,omitempty"`
	Tags         *[]Tag          `json:"tags,omitempty"`
	Type         *StackInputType `json:"type,omitempty"`
	Workdir      *string         `json:"workdir,omitempty"`
}

// StackInputType defines model for StackInput.Type.
type StackInputType string

// StackRun A stack run instance
type StackRun struct {
	Approval           *bool      `json:"approval,omitempty"`
	ApprovedAt         *time.Time `json:"approved_at,omitempty"`
	CancellationReason *string    `json:"cancellation_reason,omitempty"`
	ClusterId          *string    `json:"cluster_id,omitempty"`
	Destroy            *bool      `json:"destroy,omitempty"`
	DryRun             *bool      `json:"dry_run,omitempty"`

	// Git Git reference configuration
	Git          *Git            `json:"git,omitempty"`
	Id           *string         `json:"id,omitempty"`
	InsertedAt   *time.Time      `json:"inserted_at,omitempty"`
	ManageState  *bool           `json:"manage_state,omitempty"`
	Message      *string         `json:"message,omitempty"`
	RepositoryId *string         `json:"repository_id,omitempty"`
	StackId      *string         `json:"stack_id,omitempty"`
	Status       *StackRunStatus `json:"status,omitempty"`
	Type         *StackRunType   `json:"type,omitempty"`
	UpdatedAt    *time.Time      `json:"updated_at,omitempty"`
	Workdir      *string         `json:"workdir,omitempty"`
}

// StackRunStatus defines model for StackRun.Status.
type StackRunStatus string

// StackRunType defines model for StackRun.Type.
type StackRunType string

// StageService A service deployment within a pipeline stage
type StageService struct {
	// Criteria Criteria for promoting a service to the next stage
	Criteria *PromotionCriteria `json:"criteria,omitempty"`

	// Id Unique identifier for the stage service
	Id         *string    `json:"id,omitempty"`
	InsertedAt *time.Time `json:"inserted_at,omitempty"`

	// ServiceId ID of the deployed service
	ServiceId *string    `json:"service_id,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Tag A tag
type Tag struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// TagInput A tag used for matching clusters
type TagInput struct {
	// Name Tag name
	Name string `json:"name"`

	// Value Tag value
	Value string `json:"value"`
}

// User A registed user
type User struct {
	Email      openapi_types.Email `json:"email"`
	Id         string              `json:"id"`
	InsertedAt time.Time           `json:"inserted_at"`

	// Roles The roles of the user
	Roles          *ConsoleOpenAPIUserRoles `json:"roles,omitempty"`
	ServiceAccount *bool                    `json:"service_account,omitempty"`
	UpdatedAt      *time.Time               `json:"updated_at,omitempty"`
}

// ListAgentRunsParams defines parameters for ListAgentRuns.
type ListAgentRunsParams struct {
	RuntimeId *string `form:"runtime_id,omitempty" json:"runtime_id,omitempty"`
	Page      *int    `form:"page,omitempty" json:"page,omitempty"`
	PerPage   *int    `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListAgentRuntimesParams defines parameters for ListAgentRuntimes.
type ListAgentRuntimesParams struct {
	Type    *ListAgentRuntimesParamsType `form:"type,omitempty" json:"type,omitempty"`
	Page    *int                         `form:"page,omitempty" json:"page,omitempty"`
	PerPage *int                         `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListAgentRuntimesParamsType defines parameters for ListAgentRuntimes.
type ListAgentRuntimesParamsType string

// ListSentinelsParams defines parameters for ListSentinels.
type ListSentinelsParams struct {
	Status  *ListSentinelsParamsStatus `form:"status,omitempty" json:"status,omitempty"`
	Q       *string                    `form:"q,omitempty" json:"q,omitempty"`
	Page    *int                       `form:"page,omitempty" json:"page,omitempty"`
	PerPage *int                       `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListSentinelsParamsStatus defines parameters for ListSentinels.
type ListSentinelsParamsStatus string

// ListSentinelRunsParams defines parameters for ListSentinelRuns.
type ListSentinelRunsParams struct {
	Page    *int `form:"page,omitempty" json:"page,omitempty"`
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListAgentSessionsParams defines parameters for ListAgentSessions.
type ListAgentSessionsParams struct {
	Page    *int `form:"page,omitempty" json:"page,omitempty"`
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListClustersParams defines parameters for ListClusters.
type ListClustersParams struct {
	Q           *string                       `form:"q,omitempty" json:"q,omitempty"`
	ProjectId   *string                       `form:"project_id,omitempty" json:"project_id,omitempty"`
	Healthy     *bool                         `form:"healthy,omitempty" json:"healthy,omitempty"`
	Tag         *string                       `form:"tag,omitempty" json:"tag,omitempty"`
	Upgradeable *bool                         `form:"upgradeable,omitempty" json:"upgradeable,omitempty"`
	Compliance  *ListClustersParamsCompliance `form:"compliance,omitempty" json:"compliance,omitempty"`
	Page        *int                          `form:"page,omitempty" json:"page,omitempty"`
	PerPage     *int                          `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListClustersParamsCompliance defines parameters for ListClusters.
type ListClustersParamsCompliance string

// DeleteClusterParams defines parameters for DeleteCluster.
type DeleteClusterParams struct {
	Detach *bool `form:"detach,omitempty" json:"detach,omitempty"`
}

// ListGitRepositoriesParams defines parameters for ListGitRepositories.
type ListGitRepositoriesParams struct {
	Page    *int `form:"page,omitempty" json:"page,omitempty"`
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetGitRepositoryByUrlParams defines parameters for GetGitRepositoryByUrl.
type GetGitRepositoryByUrlParams struct {
	Url string `form:"url" json:"url"`
}

// ListGlobalServicesParams defines parameters for ListGlobalServices.
type ListGlobalServicesParams struct {
	ProjectId *string `form:"project_id,omitempty" json:"project_id,omitempty"`
	Q         *string `form:"q,omitempty" json:"q,omitempty"`
	Page      *int    `form:"page,omitempty" json:"page,omitempty"`
	PerPage   *int    `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// CreateGlobalServiceParams defines parameters for CreateGlobalService.
type CreateGlobalServiceParams struct {
	ServiceId *string `form:"service_id,omitempty" json:"service_id,omitempty"`
}

// ListHelmRepositoriesParams defines parameters for ListHelmRepositories.
type ListHelmRepositoriesParams struct {
	Page    *int `form:"page,omitempty" json:"page,omitempty"`
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetHelmRepositoryByUrlParams defines parameters for GetHelmRepositoryByUrl.
type GetHelmRepositoryByUrlParams struct {
	Url string `form:"url" json:"url"`
}

// ListPipelinesParams defines parameters for ListPipelines.
type ListPipelinesParams struct {
	ProjectId *string `form:"project_id,omitempty" json:"project_id,omitempty"`
	Q         *string `form:"q,omitempty" json:"q,omitempty"`
	Page      *int    `form:"page,omitempty" json:"page,omitempty"`
	PerPage   *int    `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListServicesParams defines parameters for ListServices.
type ListServicesParams struct {
	ClusterId *string `form:"cluster_id,omitempty" json:"cluster_id,omitempty"`
	Status    *string `form:"status,omitempty" json:"status,omitempty"`
	Q         *string `form:"q,omitempty" json:"q,omitempty"`
	Page      *int    `form:"page,omitempty" json:"page,omitempty"`
	PerPage   *int    `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// CreateServiceParams defines parameters for CreateService.
type CreateServiceParams struct {
	ClusterId string `form:"cluster_id" json:"cluster_id"`
}

// DeleteServiceParams defines parameters for DeleteService.
type DeleteServiceParams struct {
	Detach *bool `form:"detach,omitempty" json:"detach,omitempty"`
}

// ListProjectsParams defines parameters for ListProjects.
type ListProjectsParams struct {
	Page    *int `form:"page,omitempty" json:"page,omitempty"`
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListCatalogsParams defines parameters for ListCatalogs.
type ListCatalogsParams struct {
	ProjectId *string `form:"project_id,omitempty" json:"project_id,omitempty"`
	Q         *string `form:"q,omitempty" json:"q,omitempty"`
	Page      *int    `form:"page,omitempty" json:"page,omitempty"`
	PerPage   *int    `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListPrAutomationsForCatalogParams defines parameters for ListPrAutomationsForCatalog.
type ListPrAutomationsForCatalogParams struct {
	Q       *string `form:"q,omitempty" json:"q,omitempty"`
	Page    *int    `form:"page,omitempty" json:"page,omitempty"`
	PerPage *int    `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListScmConnectionsParams defines parameters for ListScmConnections.
type ListScmConnectionsParams struct {
	Page    *int `form:"page,omitempty" json:"page,omitempty"`
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListPrAutomationsParams defines parameters for ListPrAutomations.
type ListPrAutomationsParams struct {
	ProjectId *string `form:"project_id,omitempty" json:"project_id,omitempty"`
	CatalogId *string `form:"catalog_id,omitempty" json:"catalog_id,omitempty"`
	Q         *string `form:"q,omitempty" json:"q,omitempty"`
	Page      *int    `form:"page,omitempty" json:"page,omitempty"`
	PerPage   *int    `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListPullRequestsParams defines parameters for ListPullRequests.
type ListPullRequestsParams struct {
	ClusterId *string `form:"cluster_id,omitempty" json:"cluster_id,omitempty"`
	ServiceId *string `form:"service_id,omitempty" json:"service_id,omitempty"`
	StackId   *string `form:"stack_id,omitempty" json:"stack_id,omitempty"`
	Open      *bool   `form:"open,omitempty" json:"open,omitempty"`
	Q         *string `form:"q,omitempty" json:"q,omitempty"`
	Page      *int    `form:"page,omitempty" json:"page,omitempty"`
	PerPage   *int    `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListServiceAccountsParams defines parameters for ListServiceAccounts.
type ListServiceAccountsParams struct {
	Q       *string `form:"q,omitempty" json:"q,omitempty"`
	Page    *int    `form:"page,omitempty" json:"page,omitempty"`
	PerPage *int    `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// CreateServiceAccountAccessTokenParams defines parameters for CreateServiceAccountAccessToken.
type CreateServiceAccountAccessTokenParams struct {
	Refresh *bool `form:"refresh,omitempty" json:"refresh,omitempty"`
}

// ListStacksParams defines parameters for ListStacks.
type ListStacksParams struct {
	Page    *int `form:"page,omitempty" json:"page,omitempty"`
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// DeleteStackParams defines parameters for DeleteStack.
type DeleteStackParams struct {
	Detach *bool `form:"detach,omitempty" json:"detach,omitempty"`
}

// CreateAgentRunJSONRequestBody defines body for CreateAgentRun for application/json ContentType.
type CreateAgentRunJSONRequestBody = AgentRunInput

// CreateAgentSessionJSONRequestBody defines body for CreateAgentSession for application/json ContentType.
type CreateAgentSessionJSONRequestBody = AgentSessionInput

// CreateClusterJSONRequestBody defines body for CreateCluster for application/json ContentType.
type CreateClusterJSONRequestBody = ClusterInput

// UpdateClusterJSONRequestBody defines body for UpdateCluster for application/json ContentType.
type UpdateClusterJSONRequestBody = ClusterInput

// CreateClusterUpgradeJSONRequestBody defines body for CreateClusterUpgrade for application/json ContentType.
type CreateClusterUpgradeJSONRequestBody = ClusterUpgradeInput

// CreateGitRepositoryJSONRequestBody defines body for CreateGitRepository for application/json ContentType.
type CreateGitRepositoryJSONRequestBody = GitRepositoryInput

// UpdateGitRepositoryJSONRequestBody defines body for UpdateGitRepository for application/json ContentType.
type UpdateGitRepositoryJSONRequestBody = GitRepositoryInput

// CreateGlobalServiceJSONRequestBody defines body for CreateGlobalService for application/json ContentType.
type CreateGlobalServiceJSONRequestBody = GlobalServiceInput

// UpdateGlobalServiceJSONRequestBody defines body for UpdateGlobalService for application/json ContentType.
type UpdateGlobalServiceJSONRequestBody = GlobalServiceInput

// UpsertHelmRepositoryJSONRequestBody defines body for UpsertHelmRepository for application/json ContentType.
type UpsertHelmRepositoryJSONRequestBody = HelmRepositoryInput

// TriggerPipelineJSONRequestBody defines body for TriggerPipeline for application/json ContentType.
type TriggerPipelineJSONRequestBody = PipelineContextInput

// CreateServiceJSONRequestBody defines body for CreateService for application/json ContentType.
type CreateServiceJSONRequestBody = ServiceInput

// UpdateServiceJSONRequestBody defines body for UpdateService for application/json ContentType.
type UpdateServiceJSONRequestBody = ServiceInput

// UpsertCatalogJSONRequestBody defines body for UpsertCatalog for application/json ContentType.
type UpsertCatalogJSONRequestBody = CatalogInput

// UpdateCatalogJSONRequestBody defines body for UpdateCatalog for application/json ContentType.
type UpdateCatalogJSONRequestBody = CatalogInput

// CreateScmConnectionJSONRequestBody defines body for CreateScmConnection for application/json ContentType.
type CreateScmConnectionJSONRequestBody = ScmConnectionInput

// UpdateScmConnectionJSONRequestBody defines body for UpdateScmConnection for application/json ContentType.
type UpdateScmConnectionJSONRequestBody = ScmConnectionInput

// InvokePrAutomationJSONRequestBody defines body for InvokePrAutomation for application/json ContentType.
type InvokePrAutomationJSONRequestBody = CreatePullRequestInput

// CreateServiceAccountAccessTokenJSONRequestBody defines body for CreateServiceAccountAccessToken for application/json ContentType.
type CreateServiceAccountAccessTokenJSONRequestBody = AccessTokenInput

// CreateStackJSONRequestBody defines body for CreateStack for application/json ContentType.
type CreateStackJSONRequestBody = StackInput

// UpdateStackJSONRequestBody defines body for UpdateStack for application/json ContentType.
type UpdateStackJSONRequestBody = StackInput

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAgentRuns request
	ListAgentRuns(ctx context.Context, params *ListAgentRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAgentRunWithBody request with any body
	CreateAgentRunWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAgentRun(ctx context.Context, body CreateAgentRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAgentRun request
	GetAgentRun(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAgentRuntimes request
	ListAgentRuntimes(ctx context.Context, params *ListAgentRuntimesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAgentRuntime request
	GetAgentRuntime(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSentinelRun request
	GetSentinelRun(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSentinels request
	ListSentinels(ctx context.Context, params *ListSentinelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSentinel request
	GetSentinel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TriggerSentinel request
	TriggerSentinel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSentinelRuns request
	ListSentinelRuns(ctx context.Context, sentinelId string, params *ListSentinelRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAgentSessions request
	ListAgentSessions(ctx context.Context, params *ListAgentSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAgentSessionWithBody request with any body
	CreateAgentSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAgentSession(ctx context.Context, body CreateAgentSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAgentSession request
	GetAgentSession(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClusters request
	ListClusters(ctx context.Context, params *ListClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClusterWithBody request with any body
	CreateClusterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCluster(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, id string, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClusterWithBody request with any body
	UpdateClusterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCluster(ctx context.Context, id string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClusterUpgradeWithBody request with any body
	CreateClusterUpgradeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClusterUpgrade(ctx context.Context, id string, body CreateClusterUpgradeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterUpgrade request
	GetClusterUpgrade(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGitRepositories request
	ListGitRepositories(ctx context.Context, params *ListGitRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGitRepositoryWithBody request with any body
	CreateGitRepositoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGitRepository(ctx context.Context, body CreateGitRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGitRepositoryByUrl request
	GetGitRepositoryByUrl(ctx context.Context, params *GetGitRepositoryByUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGitRepository request
	DeleteGitRepository(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGitRepository request
	GetGitRepository(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGitRepositoryWithBody request with any body
	UpdateGitRepositoryWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGitRepository(ctx context.Context, id string, body UpdateGitRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGlobalServices request
	ListGlobalServices(ctx context.Context, params *ListGlobalServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGlobalServiceWithBody request with any body
	CreateGlobalServiceWithBody(ctx context.Context, params *CreateGlobalServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGlobalService(ctx context.Context, params *CreateGlobalServiceParams, body CreateGlobalServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGlobalService request
	DeleteGlobalService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobalService request
	GetGlobalService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGlobalServiceWithBody request with any body
	UpdateGlobalServiceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGlobalService(ctx context.Context, id string, body UpdateGlobalServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncGlobalService request
	SyncGlobalService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHelmRepositories request
	ListHelmRepositories(ctx context.Context, params *ListHelmRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertHelmRepositoryWithBody request with any body
	UpsertHelmRepositoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertHelmRepository(ctx context.Context, body UpsertHelmRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHelmRepositoryByUrl request
	GetHelmRepositoryByUrl(ctx context.Context, params *GetHelmRepositoryByUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHelmRepository request
	GetHelmRepository(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPipelines request
	ListPipelines(ctx context.Context, params *ListPipelinesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipeline request
	GetPipeline(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TriggerPipelineWithBody request with any body
	TriggerPipelineWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TriggerPipeline(ctx context.Context, id string, body TriggerPipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServices request
	ListServices(ctx context.Context, params *ListServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceWithBody request with any body
	CreateServiceWithBody(ctx context.Context, params *CreateServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateService(ctx context.Context, params *CreateServiceParams, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteService request
	DeleteService(ctx context.Context, id string, params *DeleteServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetService request
	GetService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceWithBody request with any body
	UpdateServiceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateService(ctx context.Context, id string, body UpdateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Me request
	Me(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjects request
	ListProjects(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCatalogs request
	ListCatalogs(ctx context.Context, params *ListCatalogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertCatalogWithBody request with any body
	UpsertCatalogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertCatalog(ctx context.Context, body UpsertCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPrAutomationsForCatalog request
	ListPrAutomationsForCatalog(ctx context.Context, catalogId string, params *ListPrAutomationsForCatalogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCatalog request
	DeleteCatalog(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalog request
	GetCatalog(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCatalogWithBody request with any body
	UpdateCatalogWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCatalog(ctx context.Context, id string, body UpdateCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListScmConnections request
	ListScmConnections(ctx context.Context, params *ListScmConnectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateScmConnectionWithBody request with any body
	CreateScmConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateScmConnection(ctx context.Context, body CreateScmConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteScmConnection request
	DeleteScmConnection(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScmConnection request
	GetScmConnection(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateScmConnectionWithBody request with any body
	UpdateScmConnectionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateScmConnection(ctx context.Context, id string, body UpdateScmConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPrAutomations request
	ListPrAutomations(ctx context.Context, params *ListPrAutomationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrAutomation request
	GetPrAutomation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InvokePrAutomationWithBody request with any body
	InvokePrAutomationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InvokePrAutomation(ctx context.Context, id string, body InvokePrAutomationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPullRequests request
	ListPullRequests(ctx context.Context, params *ListPullRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPullRequest request
	GetPullRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServiceAccounts request
	ListServiceAccounts(ctx context.Context, params *ListServiceAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceAccountByEmail request
	GetServiceAccountByEmail(ctx context.Context, email openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceAccount request
	GetServiceAccount(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceAccountAccessTokenWithBody request with any body
	CreateServiceAccountAccessTokenWithBody(ctx context.Context, id string, params *CreateServiceAccountAccessTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceAccountAccessToken(ctx context.Context, id string, params *CreateServiceAccountAccessTokenParams, body CreateServiceAccountAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStacks request
	ListStacks(ctx context.Context, params *ListStacksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStackWithBody request with any body
	CreateStackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateStack(ctx context.Context, body CreateStackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStack request
	DeleteStack(ctx context.Context, id string, params *DeleteStackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStack request
	GetStack(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateStackWithBody request with any body
	UpdateStackWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateStack(ctx context.Context, id string, body UpdateStackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreStack request
	RestoreStack(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResyncStack request
	ResyncStack(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TriggerStackRun request
	TriggerStackRun(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAgentRuns(ctx context.Context, params *ListAgentRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAgentRunsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgentRunWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentRunRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgentRun(ctx context.Context, body CreateAgentRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentRunRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAgentRun(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAgentRunRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAgentRuntimes(ctx context.Context, params *ListAgentRuntimesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAgentRuntimesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAgentRuntime(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAgentRuntimeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSentinelRun(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSentinelRunRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSentinels(ctx context.Context, params *ListSentinelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSentinelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSentinel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSentinelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerSentinel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerSentinelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSentinelRuns(ctx context.Context, sentinelId string, params *ListSentinelRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSentinelRunsRequest(c.Server, sentinelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAgentSessions(ctx context.Context, params *ListAgentSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAgentSessionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgentSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentSessionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgentSession(ctx context.Context, body CreateAgentSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentSessionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAgentSession(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAgentSessionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusters(ctx context.Context, params *ListClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClustersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCluster(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, id string, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCluster(ctx context.Context, id string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterUpgradeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterUpgradeRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterUpgrade(ctx context.Context, id string, body CreateClusterUpgradeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterUpgradeRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterUpgrade(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterUpgradeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGitRepositories(ctx context.Context, params *ListGitRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGitRepositoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGitRepositoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGitRepositoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGitRepository(ctx context.Context, body CreateGitRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGitRepositoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGitRepositoryByUrl(ctx context.Context, params *GetGitRepositoryByUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGitRepositoryByUrlRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGitRepository(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGitRepositoryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGitRepository(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGitRepositoryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGitRepositoryWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGitRepositoryRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGitRepository(ctx context.Context, id string, body UpdateGitRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGitRepositoryRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGlobalServices(ctx context.Context, params *ListGlobalServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGlobalServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGlobalServiceWithBody(ctx context.Context, params *CreateGlobalServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGlobalServiceRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGlobalService(ctx context.Context, params *CreateGlobalServiceParams, body CreateGlobalServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGlobalServiceRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGlobalService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGlobalServiceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobalService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalServiceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGlobalServiceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGlobalServiceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGlobalService(ctx context.Context, id string, body UpdateGlobalServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGlobalServiceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncGlobalService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncGlobalServiceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHelmRepositories(ctx context.Context, params *ListHelmRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHelmRepositoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertHelmRepositoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertHelmRepositoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertHelmRepository(ctx context.Context, body UpsertHelmRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertHelmRepositoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHelmRepositoryByUrl(ctx context.Context, params *GetHelmRepositoryByUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHelmRepositoryByUrlRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHelmRepository(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHelmRepositoryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPipelines(ctx context.Context, params *ListPipelinesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPipelinesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipeline(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelineRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerPipelineWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerPipelineRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerPipeline(ctx context.Context, id string, body TriggerPipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerPipelineRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServices(ctx context.Context, params *ListServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceWithBody(ctx context.Context, params *CreateServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateService(ctx context.Context, params *CreateServiceParams, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteService(ctx context.Context, id string, params *DeleteServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateService(ctx context.Context, id string, body UpdateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Me(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjects(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCatalogs(ctx context.Context, params *ListCatalogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCatalogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertCatalogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertCatalogRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertCatalog(ctx context.Context, body UpsertCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertCatalogRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPrAutomationsForCatalog(ctx context.Context, catalogId string, params *ListPrAutomationsForCatalogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPrAutomationsForCatalogRequest(c.Server, catalogId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCatalog(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCatalogRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalog(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCatalogWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCatalogRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCatalog(ctx context.Context, id string, body UpdateCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCatalogRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListScmConnections(ctx context.Context, params *ListScmConnectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListScmConnectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScmConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScmConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScmConnection(ctx context.Context, body CreateScmConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScmConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteScmConnection(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteScmConnectionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScmConnection(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScmConnectionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateScmConnectionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScmConnectionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateScmConnection(ctx context.Context, id string, body UpdateScmConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScmConnectionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPrAutomations(ctx context.Context, params *ListPrAutomationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPrAutomationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrAutomation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPrAutomationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InvokePrAutomationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInvokePrAutomationRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InvokePrAutomation(ctx context.Context, id string, body InvokePrAutomationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInvokePrAutomationRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPullRequests(ctx context.Context, params *ListPullRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPullRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPullRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPullRequestRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceAccounts(ctx context.Context, params *ListServiceAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceAccountByEmail(ctx context.Context, email openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceAccountByEmailRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceAccount(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceAccountRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountAccessTokenWithBody(ctx context.Context, id string, params *CreateServiceAccountAccessTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountAccessTokenRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountAccessToken(ctx context.Context, id string, params *CreateServiceAccountAccessTokenParams, body CreateServiceAccountAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountAccessTokenRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStacks(ctx context.Context, params *ListStacksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStacksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStackRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStack(ctx context.Context, body CreateStackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStackRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStack(ctx context.Context, id string, params *DeleteStackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStackRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStack(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStackRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStackWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStackRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStack(ctx context.Context, id string, body UpdateStackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStackRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreStack(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreStackRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResyncStack(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResyncStackRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerStackRun(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerStackRunRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAgentRunsRequest generates requests for ListAgentRuns
func NewListAgentRunsRequest(server string, params *ListAgentRunsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/ai/runs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RuntimeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runtime_id", runtime.ParamLocationQuery, *params.RuntimeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAgentRunRequest calls the generic CreateAgentRun builder with application/json body
func NewCreateAgentRunRequest(server string, body CreateAgentRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAgentRunRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAgentRunRequestWithBody generates requests for CreateAgentRun with any type of body
func NewCreateAgentRunRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/ai/runs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAgentRunRequest generates requests for GetAgentRun
func NewGetAgentRunRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/ai/runs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAgentRuntimesRequest generates requests for ListAgentRuntimes
func NewListAgentRuntimesRequest(server string, params *ListAgentRuntimesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/ai/runtimes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAgentRuntimeRequest generates requests for GetAgentRuntime
func NewGetAgentRuntimeRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/ai/runtimes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSentinelRunRequest generates requests for GetSentinelRun
func NewGetSentinelRunRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/ai/sentinelruns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSentinelsRequest generates requests for ListSentinels
func NewListSentinelsRequest(server string, params *ListSentinelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/ai/sentinels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSentinelRequest generates requests for GetSentinel
func NewGetSentinelRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/ai/sentinels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTriggerSentinelRequest generates requests for TriggerSentinel
func NewTriggerSentinelRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/ai/sentinels/%s/trigger", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSentinelRunsRequest generates requests for ListSentinelRuns
func NewListSentinelRunsRequest(server string, sentinelId string, params *ListSentinelRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sentinel_id", runtime.ParamLocationPath, sentinelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/ai/sentinels/%s/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAgentSessionsRequest generates requests for ListAgentSessions
func NewListAgentSessionsRequest(server string, params *ListAgentSessionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/ai/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAgentSessionRequest calls the generic CreateAgentSession builder with application/json body
func NewCreateAgentSessionRequest(server string, body CreateAgentSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAgentSessionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAgentSessionRequestWithBody generates requests for CreateAgentSession with any type of body
func NewCreateAgentSessionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/ai/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAgentSessionRequest generates requests for GetAgentSession
func NewGetAgentSessionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/ai/sessions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListClustersRequest generates requests for ListClusters
func NewListClustersRequest(server string, params *ListClustersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Healthy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "healthy", runtime.ParamLocationQuery, *params.Healthy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upgradeable != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upgradeable", runtime.ParamLocationQuery, *params.Upgradeable); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Compliance != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "compliance", runtime.ParamLocationQuery, *params.Compliance); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClusterRequest calls the generic CreateCluster builder with application/json body
func NewCreateClusterRequest(server string, body CreateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateClusterRequestWithBody generates requests for CreateCluster with any type of body
func NewCreateClusterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, id string, params *DeleteClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Detach != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "detach", runtime.ParamLocationQuery, *params.Detach); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterRequest calls the generic UpdateCluster builder with application/json body
func NewUpdateClusterRequest(server string, id string, body UpdateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateClusterRequestWithBody generates requests for UpdateCluster with any type of body
func NewUpdateClusterRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateClusterUpgradeRequest calls the generic CreateClusterUpgrade builder with application/json body
func NewCreateClusterUpgradeRequest(server string, id string, body CreateClusterUpgradeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterUpgradeRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateClusterUpgradeRequestWithBody generates requests for CreateClusterUpgrade with any type of body
func NewCreateClusterUpgradeRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/clusters/%s/upgrade", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClusterUpgradeRequest generates requests for GetClusterUpgrade
func NewGetClusterUpgradeRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/clusterupgrade/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGitRepositoriesRequest generates requests for ListGitRepositories
func NewListGitRepositoriesRequest(server string, params *ListGitRepositoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/git/repositories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGitRepositoryRequest calls the generic CreateGitRepository builder with application/json body
func NewCreateGitRepositoryRequest(server string, body CreateGitRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGitRepositoryRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGitRepositoryRequestWithBody generates requests for CreateGitRepository with any type of body
func NewCreateGitRepositoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/git/repositories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGitRepositoryByUrlRequest generates requests for GetGitRepositoryByUrl
func NewGetGitRepositoryByUrlRequest(server string, params *GetGitRepositoryByUrlParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/git/repositories/url")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteGitRepositoryRequest generates requests for DeleteGitRepository
func NewDeleteGitRepositoryRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/git/repositories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGitRepositoryRequest generates requests for GetGitRepository
func NewGetGitRepositoryRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/git/repositories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGitRepositoryRequest calls the generic UpdateGitRepository builder with application/json body
func NewUpdateGitRepositoryRequest(server string, id string, body UpdateGitRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGitRepositoryRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateGitRepositoryRequestWithBody generates requests for UpdateGitRepository with any type of body
func NewUpdateGitRepositoryRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/git/repositories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGlobalServicesRequest generates requests for ListGlobalServices
func NewListGlobalServicesRequest(server string, params *ListGlobalServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/globalservices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGlobalServiceRequest calls the generic CreateGlobalService builder with application/json body
func NewCreateGlobalServiceRequest(server string, params *CreateGlobalServiceParams, body CreateGlobalServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGlobalServiceRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateGlobalServiceRequestWithBody generates requests for CreateGlobalService with any type of body
func NewCreateGlobalServiceRequestWithBody(server string, params *CreateGlobalServiceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/globalservices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ServiceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service_id", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGlobalServiceRequest generates requests for DeleteGlobalService
func NewDeleteGlobalServiceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/globalservices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGlobalServiceRequest generates requests for GetGlobalService
func NewGetGlobalServiceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/globalservices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGlobalServiceRequest calls the generic UpdateGlobalService builder with application/json body
func NewUpdateGlobalServiceRequest(server string, id string, body UpdateGlobalServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGlobalServiceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateGlobalServiceRequestWithBody generates requests for UpdateGlobalService with any type of body
func NewUpdateGlobalServiceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/globalservices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncGlobalServiceRequest generates requests for SyncGlobalService
func NewSyncGlobalServiceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/globalservices/%s/sync", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListHelmRepositoriesRequest generates requests for ListHelmRepositories
func NewListHelmRepositoriesRequest(server string, params *ListHelmRepositoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/helm/repositories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpsertHelmRepositoryRequest calls the generic UpsertHelmRepository builder with application/json body
func NewUpsertHelmRepositoryRequest(server string, body UpsertHelmRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertHelmRepositoryRequestWithBody(server, "application/json", bodyReader)
}

// NewUpsertHelmRepositoryRequestWithBody generates requests for UpsertHelmRepository with any type of body
func NewUpsertHelmRepositoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/helm/repositories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHelmRepositoryByUrlRequest generates requests for GetHelmRepositoryByUrl
func NewGetHelmRepositoryByUrlRequest(server string, params *GetHelmRepositoryByUrlParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/helm/repositories/url")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHelmRepositoryRequest generates requests for GetHelmRepository
func NewGetHelmRepositoryRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/helm/repositories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPipelinesRequest generates requests for ListPipelines
func NewListPipelinesRequest(server string, params *ListPipelinesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/pipelines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelineRequest generates requests for GetPipeline
func NewGetPipelineRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/pipelines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTriggerPipelineRequest calls the generic TriggerPipeline builder with application/json body
func NewTriggerPipelineRequest(server string, id string, body TriggerPipelineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTriggerPipelineRequestWithBody(server, id, "application/json", bodyReader)
}

// NewTriggerPipelineRequestWithBody generates requests for TriggerPipeline with any type of body
func NewTriggerPipelineRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/pipelines/%s/trigger", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListServicesRequest generates requests for ListServices
func NewListServicesRequest(server string, params *ListServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClusterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cluster_id", runtime.ParamLocationQuery, *params.ClusterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServiceRequest calls the generic CreateService builder with application/json body
func NewCreateServiceRequest(server string, params *CreateServiceParams, body CreateServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateServiceRequestWithBody generates requests for CreateService with any type of body
func NewCreateServiceRequestWithBody(server string, params *CreateServiceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cluster_id", runtime.ParamLocationQuery, params.ClusterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceRequest generates requests for DeleteService
func NewDeleteServiceRequest(server string, id string, params *DeleteServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Detach != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "detach", runtime.ParamLocationQuery, *params.Detach); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceRequest generates requests for GetService
func NewGetServiceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceRequest calls the generic UpdateService builder with application/json body
func NewUpdateServiceRequest(server string, id string, body UpdateServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateServiceRequestWithBody generates requests for UpdateService with any type of body
func NewUpdateServiceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/cd/services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeRequest generates requests for Me
func NewMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectsRequest generates requests for ListProjects
func NewListProjectsRequest(server string, params *ListProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCatalogsRequest generates requests for ListCatalogs
func NewListCatalogsRequest(server string, params *ListCatalogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/scm/catalogs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpsertCatalogRequest calls the generic UpsertCatalog builder with application/json body
func NewUpsertCatalogRequest(server string, body UpsertCatalogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertCatalogRequestWithBody(server, "application/json", bodyReader)
}

// NewUpsertCatalogRequestWithBody generates requests for UpsertCatalog with any type of body
func NewUpsertCatalogRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/scm/catalogs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPrAutomationsForCatalogRequest generates requests for ListPrAutomationsForCatalog
func NewListPrAutomationsForCatalogRequest(server string, catalogId string, params *ListPrAutomationsForCatalogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "catalog_id", runtime.ParamLocationPath, catalogId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/scm/catalogs/%s/prautomations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCatalogRequest generates requests for DeleteCatalog
func NewDeleteCatalogRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/scm/catalogs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogRequest generates requests for GetCatalog
func NewGetCatalogRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/scm/catalogs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCatalogRequest calls the generic UpdateCatalog builder with application/json body
func NewUpdateCatalogRequest(server string, id string, body UpdateCatalogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCatalogRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateCatalogRequestWithBody generates requests for UpdateCatalog with any type of body
func NewUpdateCatalogRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/scm/catalogs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListScmConnectionsRequest generates requests for ListScmConnections
func NewListScmConnectionsRequest(server string, params *ListScmConnectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/scm/connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateScmConnectionRequest calls the generic CreateScmConnection builder with application/json body
func NewCreateScmConnectionRequest(server string, body CreateScmConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateScmConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateScmConnectionRequestWithBody generates requests for CreateScmConnection with any type of body
func NewCreateScmConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/scm/connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteScmConnectionRequest generates requests for DeleteScmConnection
func NewDeleteScmConnectionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/scm/connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScmConnectionRequest generates requests for GetScmConnection
func NewGetScmConnectionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/scm/connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateScmConnectionRequest calls the generic UpdateScmConnection builder with application/json body
func NewUpdateScmConnectionRequest(server string, id string, body UpdateScmConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateScmConnectionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateScmConnectionRequestWithBody generates requests for UpdateScmConnection with any type of body
func NewUpdateScmConnectionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/scm/connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPrAutomationsRequest generates requests for ListPrAutomations
func NewListPrAutomationsRequest(server string, params *ListPrAutomationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/scm/prautomations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_id", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CatalogId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "catalog_id", runtime.ParamLocationQuery, *params.CatalogId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPrAutomationRequest generates requests for GetPrAutomation
func NewGetPrAutomationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/scm/prautomations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInvokePrAutomationRequest calls the generic InvokePrAutomation builder with application/json body
func NewInvokePrAutomationRequest(server string, id string, body InvokePrAutomationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInvokePrAutomationRequestWithBody(server, id, "application/json", bodyReader)
}

// NewInvokePrAutomationRequestWithBody generates requests for InvokePrAutomation with any type of body
func NewInvokePrAutomationRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/scm/prautomations/%s/invoke", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPullRequestsRequest generates requests for ListPullRequests
func NewListPullRequestsRequest(server string, params *ListPullRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/scm/pullrequests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClusterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cluster_id", runtime.ParamLocationQuery, *params.ClusterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ServiceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service_id", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StackId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stack_id", runtime.ParamLocationQuery, *params.StackId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Open != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "open", runtime.ParamLocationQuery, *params.Open); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPullRequestRequest generates requests for GetPullRequest
func NewGetPullRequestRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/scm/pullrequests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListServiceAccountsRequest generates requests for ListServiceAccounts
func NewListServiceAccountsRequest(server string, params *ListServiceAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/serviceaccounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceAccountByEmailRequest generates requests for GetServiceAccountByEmail
func NewGetServiceAccountByEmailRequest(server string, email openapi_types.Email) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/serviceaccounts/email/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceAccountRequest generates requests for GetServiceAccount
func NewGetServiceAccountRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/serviceaccounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServiceAccountAccessTokenRequest calls the generic CreateServiceAccountAccessToken builder with application/json body
func NewCreateServiceAccountAccessTokenRequest(server string, id string, params *CreateServiceAccountAccessTokenParams, body CreateServiceAccountAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceAccountAccessTokenRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewCreateServiceAccountAccessTokenRequestWithBody generates requests for CreateServiceAccountAccessToken with any type of body
func NewCreateServiceAccountAccessTokenRequestWithBody(server string, id string, params *CreateServiceAccountAccessTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/serviceaccounts/%s/token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Refresh != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refresh", runtime.ParamLocationQuery, *params.Refresh); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListStacksRequest generates requests for ListStacks
func NewListStacksRequest(server string, params *ListStacksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/stacks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStackRequest calls the generic CreateStack builder with application/json body
func NewCreateStackRequest(server string, body CreateStackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateStackRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateStackRequestWithBody generates requests for CreateStack with any type of body
func NewCreateStackRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/stacks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStackRequest generates requests for DeleteStack
func NewDeleteStackRequest(server string, id string, params *DeleteStackParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/stacks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Detach != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "detach", runtime.ParamLocationQuery, *params.Detach); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStackRequest generates requests for GetStack
func NewGetStackRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/stacks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateStackRequest calls the generic UpdateStack builder with application/json body
func NewUpdateStackRequest(server string, id string, body UpdateStackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateStackRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateStackRequestWithBody generates requests for UpdateStack with any type of body
func NewUpdateStackRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/stacks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestoreStackRequest generates requests for RestoreStack
func NewRestoreStackRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/stacks/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResyncStackRequest generates requests for ResyncStack
func NewResyncStackRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/stacks/%s/resync", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTriggerStackRunRequest generates requests for TriggerStackRun
func NewTriggerStackRunRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/api/stacks/%s/trigger", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAgentRunsWithResponse request
	ListAgentRunsWithResponse(ctx context.Context, params *ListAgentRunsParams, reqEditors ...RequestEditorFn) (*ListAgentRunsResponse, error)

	// CreateAgentRunWithBodyWithResponse request with any body
	CreateAgentRunWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentRunResponse, error)

	CreateAgentRunWithResponse(ctx context.Context, body CreateAgentRunJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentRunResponse, error)

	// GetAgentRunWithResponse request
	GetAgentRunWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAgentRunResponse, error)

	// ListAgentRuntimesWithResponse request
	ListAgentRuntimesWithResponse(ctx context.Context, params *ListAgentRuntimesParams, reqEditors ...RequestEditorFn) (*ListAgentRuntimesResponse, error)

	// GetAgentRuntimeWithResponse request
	GetAgentRuntimeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAgentRuntimeResponse, error)

	// GetSentinelRunWithResponse request
	GetSentinelRunWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSentinelRunResponse, error)

	// ListSentinelsWithResponse request
	ListSentinelsWithResponse(ctx context.Context, params *ListSentinelsParams, reqEditors ...RequestEditorFn) (*ListSentinelsResponse, error)

	// GetSentinelWithResponse request
	GetSentinelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSentinelResponse, error)

	// TriggerSentinelWithResponse request
	TriggerSentinelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*TriggerSentinelResponse, error)

	// ListSentinelRunsWithResponse request
	ListSentinelRunsWithResponse(ctx context.Context, sentinelId string, params *ListSentinelRunsParams, reqEditors ...RequestEditorFn) (*ListSentinelRunsResponse, error)

	// ListAgentSessionsWithResponse request
	ListAgentSessionsWithResponse(ctx context.Context, params *ListAgentSessionsParams, reqEditors ...RequestEditorFn) (*ListAgentSessionsResponse, error)

	// CreateAgentSessionWithBodyWithResponse request with any body
	CreateAgentSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentSessionResponse, error)

	CreateAgentSessionWithResponse(ctx context.Context, body CreateAgentSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentSessionResponse, error)

	// GetAgentSessionWithResponse request
	GetAgentSessionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAgentSessionResponse, error)

	// ListClustersWithResponse request
	ListClustersWithResponse(ctx context.Context, params *ListClustersParams, reqEditors ...RequestEditorFn) (*ListClustersResponse, error)

	// CreateClusterWithBodyWithResponse request with any body
	CreateClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	CreateClusterWithResponse(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	// DeleteClusterWithResponse request
	DeleteClusterWithResponse(ctx context.Context, id string, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetClusterWithResponse request
	GetClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// UpdateClusterWithBodyWithResponse request with any body
	UpdateClusterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	UpdateClusterWithResponse(ctx context.Context, id string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	// CreateClusterUpgradeWithBodyWithResponse request with any body
	CreateClusterUpgradeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterUpgradeResponse, error)

	CreateClusterUpgradeWithResponse(ctx context.Context, id string, body CreateClusterUpgradeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterUpgradeResponse, error)

	// GetClusterUpgradeWithResponse request
	GetClusterUpgradeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetClusterUpgradeResponse, error)

	// ListGitRepositoriesWithResponse request
	ListGitRepositoriesWithResponse(ctx context.Context, params *ListGitRepositoriesParams, reqEditors ...RequestEditorFn) (*ListGitRepositoriesResponse, error)

	// CreateGitRepositoryWithBodyWithResponse request with any body
	CreateGitRepositoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGitRepositoryResponse, error)

	CreateGitRepositoryWithResponse(ctx context.Context, body CreateGitRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGitRepositoryResponse, error)

	// GetGitRepositoryByUrlWithResponse request
	GetGitRepositoryByUrlWithResponse(ctx context.Context, params *GetGitRepositoryByUrlParams, reqEditors ...RequestEditorFn) (*GetGitRepositoryByUrlResponse, error)

	// DeleteGitRepositoryWithResponse request
	DeleteGitRepositoryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteGitRepositoryResponse, error)

	// GetGitRepositoryWithResponse request
	GetGitRepositoryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetGitRepositoryResponse, error)

	// UpdateGitRepositoryWithBodyWithResponse request with any body
	UpdateGitRepositoryWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGitRepositoryResponse, error)

	UpdateGitRepositoryWithResponse(ctx context.Context, id string, body UpdateGitRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGitRepositoryResponse, error)

	// ListGlobalServicesWithResponse request
	ListGlobalServicesWithResponse(ctx context.Context, params *ListGlobalServicesParams, reqEditors ...RequestEditorFn) (*ListGlobalServicesResponse, error)

	// CreateGlobalServiceWithBodyWithResponse request with any body
	CreateGlobalServiceWithBodyWithResponse(ctx context.Context, params *CreateGlobalServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGlobalServiceResponse, error)

	CreateGlobalServiceWithResponse(ctx context.Context, params *CreateGlobalServiceParams, body CreateGlobalServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGlobalServiceResponse, error)

	// DeleteGlobalServiceWithResponse request
	DeleteGlobalServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteGlobalServiceResponse, error)

	// GetGlobalServiceWithResponse request
	GetGlobalServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetGlobalServiceResponse, error)

	// UpdateGlobalServiceWithBodyWithResponse request with any body
	UpdateGlobalServiceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGlobalServiceResponse, error)

	UpdateGlobalServiceWithResponse(ctx context.Context, id string, body UpdateGlobalServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGlobalServiceResponse, error)

	// SyncGlobalServiceWithResponse request
	SyncGlobalServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SyncGlobalServiceResponse, error)

	// ListHelmRepositoriesWithResponse request
	ListHelmRepositoriesWithResponse(ctx context.Context, params *ListHelmRepositoriesParams, reqEditors ...RequestEditorFn) (*ListHelmRepositoriesResponse, error)

	// UpsertHelmRepositoryWithBodyWithResponse request with any body
	UpsertHelmRepositoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertHelmRepositoryResponse, error)

	UpsertHelmRepositoryWithResponse(ctx context.Context, body UpsertHelmRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertHelmRepositoryResponse, error)

	// GetHelmRepositoryByUrlWithResponse request
	GetHelmRepositoryByUrlWithResponse(ctx context.Context, params *GetHelmRepositoryByUrlParams, reqEditors ...RequestEditorFn) (*GetHelmRepositoryByUrlResponse, error)

	// GetHelmRepositoryWithResponse request
	GetHelmRepositoryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHelmRepositoryResponse, error)

	// ListPipelinesWithResponse request
	ListPipelinesWithResponse(ctx context.Context, params *ListPipelinesParams, reqEditors ...RequestEditorFn) (*ListPipelinesResponse, error)

	// GetPipelineWithResponse request
	GetPipelineWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPipelineResponse, error)

	// TriggerPipelineWithBodyWithResponse request with any body
	TriggerPipelineWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TriggerPipelineResponse, error)

	TriggerPipelineWithResponse(ctx context.Context, id string, body TriggerPipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*TriggerPipelineResponse, error)

	// ListServicesWithResponse request
	ListServicesWithResponse(ctx context.Context, params *ListServicesParams, reqEditors ...RequestEditorFn) (*ListServicesResponse, error)

	// CreateServiceWithBodyWithResponse request with any body
	CreateServiceWithBodyWithResponse(ctx context.Context, params *CreateServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error)

	CreateServiceWithResponse(ctx context.Context, params *CreateServiceParams, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error)

	// DeleteServiceWithResponse request
	DeleteServiceWithResponse(ctx context.Context, id string, params *DeleteServiceParams, reqEditors ...RequestEditorFn) (*DeleteServiceResponse, error)

	// GetServiceWithResponse request
	GetServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetServiceResponse, error)

	// UpdateServiceWithBodyWithResponse request with any body
	UpdateServiceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceResponse, error)

	UpdateServiceWithResponse(ctx context.Context, id string, body UpdateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceResponse, error)

	// MeWithResponse request
	MeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MeResponse, error)

	// ListProjectsWithResponse request
	ListProjectsWithResponse(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error)

	// ListCatalogsWithResponse request
	ListCatalogsWithResponse(ctx context.Context, params *ListCatalogsParams, reqEditors ...RequestEditorFn) (*ListCatalogsResponse, error)

	// UpsertCatalogWithBodyWithResponse request with any body
	UpsertCatalogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertCatalogResponse, error)

	UpsertCatalogWithResponse(ctx context.Context, body UpsertCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertCatalogResponse, error)

	// ListPrAutomationsForCatalogWithResponse request
	ListPrAutomationsForCatalogWithResponse(ctx context.Context, catalogId string, params *ListPrAutomationsForCatalogParams, reqEditors ...RequestEditorFn) (*ListPrAutomationsForCatalogResponse, error)

	// DeleteCatalogWithResponse request
	DeleteCatalogWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCatalogResponse, error)

	// GetCatalogWithResponse request
	GetCatalogWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCatalogResponse, error)

	// UpdateCatalogWithBodyWithResponse request with any body
	UpdateCatalogWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCatalogResponse, error)

	UpdateCatalogWithResponse(ctx context.Context, id string, body UpdateCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCatalogResponse, error)

	// ListScmConnectionsWithResponse request
	ListScmConnectionsWithResponse(ctx context.Context, params *ListScmConnectionsParams, reqEditors ...RequestEditorFn) (*ListScmConnectionsResponse, error)

	// CreateScmConnectionWithBodyWithResponse request with any body
	CreateScmConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScmConnectionResponse, error)

	CreateScmConnectionWithResponse(ctx context.Context, body CreateScmConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScmConnectionResponse, error)

	// DeleteScmConnectionWithResponse request
	DeleteScmConnectionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteScmConnectionResponse, error)

	// GetScmConnectionWithResponse request
	GetScmConnectionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetScmConnectionResponse, error)

	// UpdateScmConnectionWithBodyWithResponse request with any body
	UpdateScmConnectionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScmConnectionResponse, error)

	UpdateScmConnectionWithResponse(ctx context.Context, id string, body UpdateScmConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScmConnectionResponse, error)

	// ListPrAutomationsWithResponse request
	ListPrAutomationsWithResponse(ctx context.Context, params *ListPrAutomationsParams, reqEditors ...RequestEditorFn) (*ListPrAutomationsResponse, error)

	// GetPrAutomationWithResponse request
	GetPrAutomationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPrAutomationResponse, error)

	// InvokePrAutomationWithBodyWithResponse request with any body
	InvokePrAutomationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InvokePrAutomationResponse, error)

	InvokePrAutomationWithResponse(ctx context.Context, id string, body InvokePrAutomationJSONRequestBody, reqEditors ...RequestEditorFn) (*InvokePrAutomationResponse, error)

	// ListPullRequestsWithResponse request
	ListPullRequestsWithResponse(ctx context.Context, params *ListPullRequestsParams, reqEditors ...RequestEditorFn) (*ListPullRequestsResponse, error)

	// GetPullRequestWithResponse request
	GetPullRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPullRequestResponse, error)

	// ListServiceAccountsWithResponse request
	ListServiceAccountsWithResponse(ctx context.Context, params *ListServiceAccountsParams, reqEditors ...RequestEditorFn) (*ListServiceAccountsResponse, error)

	// GetServiceAccountByEmailWithResponse request
	GetServiceAccountByEmailWithResponse(ctx context.Context, email openapi_types.Email, reqEditors ...RequestEditorFn) (*GetServiceAccountByEmailResponse, error)

	// GetServiceAccountWithResponse request
	GetServiceAccountWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetServiceAccountResponse, error)

	// CreateServiceAccountAccessTokenWithBodyWithResponse request with any body
	CreateServiceAccountAccessTokenWithBodyWithResponse(ctx context.Context, id string, params *CreateServiceAccountAccessTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountAccessTokenResponse, error)

	CreateServiceAccountAccessTokenWithResponse(ctx context.Context, id string, params *CreateServiceAccountAccessTokenParams, body CreateServiceAccountAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountAccessTokenResponse, error)

	// ListStacksWithResponse request
	ListStacksWithResponse(ctx context.Context, params *ListStacksParams, reqEditors ...RequestEditorFn) (*ListStacksResponse, error)

	// CreateStackWithBodyWithResponse request with any body
	CreateStackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStackResponse, error)

	CreateStackWithResponse(ctx context.Context, body CreateStackJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStackResponse, error)

	// DeleteStackWithResponse request
	DeleteStackWithResponse(ctx context.Context, id string, params *DeleteStackParams, reqEditors ...RequestEditorFn) (*DeleteStackResponse, error)

	// GetStackWithResponse request
	GetStackWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetStackResponse, error)

	// UpdateStackWithBodyWithResponse request with any body
	UpdateStackWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStackResponse, error)

	UpdateStackWithResponse(ctx context.Context, id string, body UpdateStackJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStackResponse, error)

	// RestoreStackWithResponse request
	RestoreStackWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RestoreStackResponse, error)

	// ResyncStackWithResponse request
	ResyncStackWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ResyncStackResponse, error)

	// TriggerStackRunWithResponse request
	TriggerStackRunWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*TriggerStackRunResponse, error)
}

type ListAgentRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPIAIAgentRunList
}

// Status returns HTTPResponse.Status
func (r ListAgentRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAgentRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAgentRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AgentRun
}

// Status returns HTTPResponse.Status
func (r CreateAgentRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAgentRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAgentRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AgentRun
}

// Status returns HTTPResponse.Status
func (r GetAgentRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAgentRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAgentRuntimesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPIAIAgentRuntimeList
}

// Status returns HTTPResponse.Status
func (r ListAgentRuntimesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAgentRuntimesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAgentRuntimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AgentRuntime
}

// Status returns HTTPResponse.Status
func (r GetAgentRuntimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAgentRuntimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSentinelRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SentinelRun
}

// Status returns HTTPResponse.Status
func (r GetSentinelRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSentinelRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSentinelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPIAISentinelList
}

// Status returns HTTPResponse.Status
func (r ListSentinelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSentinelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSentinelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sentinel
}

// Status returns HTTPResponse.Status
func (r GetSentinelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSentinelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerSentinelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SentinelRun
}

// Status returns HTTPResponse.Status
func (r TriggerSentinelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerSentinelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSentinelRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPIAISentinelRunList
}

// Status returns HTTPResponse.Status
func (r ListSentinelRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSentinelRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAgentSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPIAIAgentSessionList
}

// Status returns HTTPResponse.Status
func (r ListAgentSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAgentSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAgentSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AgentSession
}

// Status returns HTTPResponse.Status
func (r CreateAgentSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAgentSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAgentSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AgentSession
}

// Status returns HTTPResponse.Status
func (r GetAgentSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAgentSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPICDClusterList
}

// Status returns HTTPResponse.Status
func (r ListClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cluster
}

// Status returns HTTPResponse.Status
func (r CreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cluster
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cluster
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cluster
}

// Status returns HTTPResponse.Status
func (r UpdateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterUpgradeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterUpgrade
}

// Status returns HTTPResponse.Status
func (r CreateClusterUpgradeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterUpgradeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterUpgradeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterUpgrade
}

// Status returns HTTPResponse.Status
func (r GetClusterUpgradeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterUpgradeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGitRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPICDGitRepositoryList
}

// Status returns HTTPResponse.Status
func (r ListGitRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGitRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGitRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitRepository
}

// Status returns HTTPResponse.Status
func (r CreateGitRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGitRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGitRepositoryByUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitRepository
}

// Status returns HTTPResponse.Status
func (r GetGitRepositoryByUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGitRepositoryByUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGitRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitRepository
}

// Status returns HTTPResponse.Status
func (r DeleteGitRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGitRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGitRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitRepository
}

// Status returns HTTPResponse.Status
func (r GetGitRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGitRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGitRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitRepository
}

// Status returns HTTPResponse.Status
func (r UpdateGitRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGitRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGlobalServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPICDGlobalServiceList
}

// Status returns HTTPResponse.Status
func (r ListGlobalServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGlobalServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGlobalServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalService
}

// Status returns HTTPResponse.Status
func (r CreateGlobalServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGlobalServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGlobalServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalService
}

// Status returns HTTPResponse.Status
func (r DeleteGlobalServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGlobalServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalService
}

// Status returns HTTPResponse.Status
func (r GetGlobalServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGlobalServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalService
}

// Status returns HTTPResponse.Status
func (r UpdateGlobalServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGlobalServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncGlobalServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalService
}

// Status returns HTTPResponse.Status
func (r SyncGlobalServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncGlobalServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHelmRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPICDHelmRepositoryList
}

// Status returns HTTPResponse.Status
func (r ListHelmRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHelmRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertHelmRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HelmRepository
}

// Status returns HTTPResponse.Status
func (r UpsertHelmRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertHelmRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHelmRepositoryByUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HelmRepository
}

// Status returns HTTPResponse.Status
func (r GetHelmRepositoryByUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHelmRepositoryByUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHelmRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HelmRepository
}

// Status returns HTTPResponse.Status
func (r GetHelmRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHelmRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPipelinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPICDPipelineList
}

// Status returns HTTPResponse.Status
func (r ListPipelinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPipelinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Pipeline
}

// Status returns HTTPResponse.Status
func (r GetPipelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerPipelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PipelineContext
}

// Status returns HTTPResponse.Status
func (r TriggerPipelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerPipelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPICDServiceList
}

// Status returns HTTPResponse.Status
func (r ListServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Service
}

// Status returns HTTPResponse.Status
func (r CreateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Service
}

// Status returns HTTPResponse.Status
func (r DeleteServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Service
}

// Status returns HTTPResponse.Status
func (r GetServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Service
}

// Status returns HTTPResponse.Status
func (r UpdateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r MeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPIProjectList
}

// Status returns HTTPResponse.Status
func (r ListProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCatalogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPISCMCatalogList
}

// Status returns HTTPResponse.Status
func (r ListCatalogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCatalogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertCatalogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Catalog
}

// Status returns HTTPResponse.Status
func (r UpsertCatalogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertCatalogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPrAutomationsForCatalogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPISCMPrAutomationList
}

// Status returns HTTPResponse.Status
func (r ListPrAutomationsForCatalogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPrAutomationsForCatalogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCatalogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Catalog
}

// Status returns HTTPResponse.Status
func (r DeleteCatalogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCatalogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Catalog
}

// Status returns HTTPResponse.Status
func (r GetCatalogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCatalogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Catalog
}

// Status returns HTTPResponse.Status
func (r UpdateCatalogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCatalogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListScmConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPISCMConnectionList
}

// Status returns HTTPResponse.Status
func (r ListScmConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListScmConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateScmConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScmConnection
}

// Status returns HTTPResponse.Status
func (r CreateScmConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateScmConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteScmConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScmConnection
}

// Status returns HTTPResponse.Status
func (r DeleteScmConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteScmConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScmConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScmConnection
}

// Status returns HTTPResponse.Status
func (r GetScmConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScmConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateScmConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScmConnection
}

// Status returns HTTPResponse.Status
func (r UpdateScmConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateScmConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPrAutomationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPISCMPrAutomationList
}

// Status returns HTTPResponse.Status
func (r ListPrAutomationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPrAutomationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPrAutomationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrAutomation
}

// Status returns HTTPResponse.Status
func (r GetPrAutomationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPrAutomationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InvokePrAutomationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequest
}

// Status returns HTTPResponse.Status
func (r InvokePrAutomationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InvokePrAutomationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPullRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPISCMPullRequestList
}

// Status returns HTTPResponse.Status
func (r ListPullRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPullRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPullRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequest
}

// Status returns HTTPResponse.Status
func (r GetPullRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPullRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPIUserList
}

// Status returns HTTPResponse.Status
func (r ListServiceAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceAccountByEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r GetServiceAccountByEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceAccountByEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r GetServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceAccountAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessToken
}

// Status returns HTTPResponse.Status
func (r CreateServiceAccountAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceAccountAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStacksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsoleOpenAPIStackList
}

// Status returns HTTPResponse.Status
func (r ListStacksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStacksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Stack
}

// Status returns HTTPResponse.Status
func (r CreateStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Stack
}

// Status returns HTTPResponse.Status
func (r DeleteStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Stack
}

// Status returns HTTPResponse.Status
func (r GetStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateStackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Stack
}

// Status returns HTTPResponse.Status
func (r UpdateStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreStackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Stack
}

// Status returns HTTPResponse.Status
func (r RestoreStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResyncStackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StackRun
}

// Status returns HTTPResponse.Status
func (r ResyncStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResyncStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerStackRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StackRun
}

// Status returns HTTPResponse.Status
func (r TriggerStackRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerStackRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAgentRunsWithResponse request returning *ListAgentRunsResponse
func (c *ClientWithResponses) ListAgentRunsWithResponse(ctx context.Context, params *ListAgentRunsParams, reqEditors ...RequestEditorFn) (*ListAgentRunsResponse, error) {
	rsp, err := c.ListAgentRuns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAgentRunsResponse(rsp)
}

// CreateAgentRunWithBodyWithResponse request with arbitrary body returning *CreateAgentRunResponse
func (c *ClientWithResponses) CreateAgentRunWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentRunResponse, error) {
	rsp, err := c.CreateAgentRunWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentRunResponse(rsp)
}

func (c *ClientWithResponses) CreateAgentRunWithResponse(ctx context.Context, body CreateAgentRunJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentRunResponse, error) {
	rsp, err := c.CreateAgentRun(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentRunResponse(rsp)
}

// GetAgentRunWithResponse request returning *GetAgentRunResponse
func (c *ClientWithResponses) GetAgentRunWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAgentRunResponse, error) {
	rsp, err := c.GetAgentRun(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAgentRunResponse(rsp)
}

// ListAgentRuntimesWithResponse request returning *ListAgentRuntimesResponse
func (c *ClientWithResponses) ListAgentRuntimesWithResponse(ctx context.Context, params *ListAgentRuntimesParams, reqEditors ...RequestEditorFn) (*ListAgentRuntimesResponse, error) {
	rsp, err := c.ListAgentRuntimes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAgentRuntimesResponse(rsp)
}

// GetAgentRuntimeWithResponse request returning *GetAgentRuntimeResponse
func (c *ClientWithResponses) GetAgentRuntimeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAgentRuntimeResponse, error) {
	rsp, err := c.GetAgentRuntime(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAgentRuntimeResponse(rsp)
}

// GetSentinelRunWithResponse request returning *GetSentinelRunResponse
func (c *ClientWithResponses) GetSentinelRunWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSentinelRunResponse, error) {
	rsp, err := c.GetSentinelRun(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSentinelRunResponse(rsp)
}

// ListSentinelsWithResponse request returning *ListSentinelsResponse
func (c *ClientWithResponses) ListSentinelsWithResponse(ctx context.Context, params *ListSentinelsParams, reqEditors ...RequestEditorFn) (*ListSentinelsResponse, error) {
	rsp, err := c.ListSentinels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSentinelsResponse(rsp)
}

// GetSentinelWithResponse request returning *GetSentinelResponse
func (c *ClientWithResponses) GetSentinelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSentinelResponse, error) {
	rsp, err := c.GetSentinel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSentinelResponse(rsp)
}

// TriggerSentinelWithResponse request returning *TriggerSentinelResponse
func (c *ClientWithResponses) TriggerSentinelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*TriggerSentinelResponse, error) {
	rsp, err := c.TriggerSentinel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerSentinelResponse(rsp)
}

// ListSentinelRunsWithResponse request returning *ListSentinelRunsResponse
func (c *ClientWithResponses) ListSentinelRunsWithResponse(ctx context.Context, sentinelId string, params *ListSentinelRunsParams, reqEditors ...RequestEditorFn) (*ListSentinelRunsResponse, error) {
	rsp, err := c.ListSentinelRuns(ctx, sentinelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSentinelRunsResponse(rsp)
}

// ListAgentSessionsWithResponse request returning *ListAgentSessionsResponse
func (c *ClientWithResponses) ListAgentSessionsWithResponse(ctx context.Context, params *ListAgentSessionsParams, reqEditors ...RequestEditorFn) (*ListAgentSessionsResponse, error) {
	rsp, err := c.ListAgentSessions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAgentSessionsResponse(rsp)
}

// CreateAgentSessionWithBodyWithResponse request with arbitrary body returning *CreateAgentSessionResponse
func (c *ClientWithResponses) CreateAgentSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentSessionResponse, error) {
	rsp, err := c.CreateAgentSessionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentSessionResponse(rsp)
}

func (c *ClientWithResponses) CreateAgentSessionWithResponse(ctx context.Context, body CreateAgentSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentSessionResponse, error) {
	rsp, err := c.CreateAgentSession(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentSessionResponse(rsp)
}

// GetAgentSessionWithResponse request returning *GetAgentSessionResponse
func (c *ClientWithResponses) GetAgentSessionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAgentSessionResponse, error) {
	rsp, err := c.GetAgentSession(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAgentSessionResponse(rsp)
}

// ListClustersWithResponse request returning *ListClustersResponse
func (c *ClientWithResponses) ListClustersWithResponse(ctx context.Context, params *ListClustersParams, reqEditors ...RequestEditorFn) (*ListClustersResponse, error) {
	rsp, err := c.ListClusters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClustersResponse(rsp)
}

// CreateClusterWithBodyWithResponse request with arbitrary body returning *CreateClusterResponse
func (c *ClientWithResponses) CreateClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateClusterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterWithResponse(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateCluster(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, id string, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// UpdateClusterWithBodyWithResponse request with arbitrary body returning *UpdateClusterResponse
func (c *ClientWithResponses) UpdateClusterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateClusterWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterWithResponse(ctx context.Context, id string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateCluster(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

// CreateClusterUpgradeWithBodyWithResponse request with arbitrary body returning *CreateClusterUpgradeResponse
func (c *ClientWithResponses) CreateClusterUpgradeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterUpgradeResponse, error) {
	rsp, err := c.CreateClusterUpgradeWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterUpgradeResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterUpgradeWithResponse(ctx context.Context, id string, body CreateClusterUpgradeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterUpgradeResponse, error) {
	rsp, err := c.CreateClusterUpgrade(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterUpgradeResponse(rsp)
}

// GetClusterUpgradeWithResponse request returning *GetClusterUpgradeResponse
func (c *ClientWithResponses) GetClusterUpgradeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetClusterUpgradeResponse, error) {
	rsp, err := c.GetClusterUpgrade(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterUpgradeResponse(rsp)
}

// ListGitRepositoriesWithResponse request returning *ListGitRepositoriesResponse
func (c *ClientWithResponses) ListGitRepositoriesWithResponse(ctx context.Context, params *ListGitRepositoriesParams, reqEditors ...RequestEditorFn) (*ListGitRepositoriesResponse, error) {
	rsp, err := c.ListGitRepositories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGitRepositoriesResponse(rsp)
}

// CreateGitRepositoryWithBodyWithResponse request with arbitrary body returning *CreateGitRepositoryResponse
func (c *ClientWithResponses) CreateGitRepositoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGitRepositoryResponse, error) {
	rsp, err := c.CreateGitRepositoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGitRepositoryResponse(rsp)
}

func (c *ClientWithResponses) CreateGitRepositoryWithResponse(ctx context.Context, body CreateGitRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGitRepositoryResponse, error) {
	rsp, err := c.CreateGitRepository(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGitRepositoryResponse(rsp)
}

// GetGitRepositoryByUrlWithResponse request returning *GetGitRepositoryByUrlResponse
func (c *ClientWithResponses) GetGitRepositoryByUrlWithResponse(ctx context.Context, params *GetGitRepositoryByUrlParams, reqEditors ...RequestEditorFn) (*GetGitRepositoryByUrlResponse, error) {
	rsp, err := c.GetGitRepositoryByUrl(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGitRepositoryByUrlResponse(rsp)
}

// DeleteGitRepositoryWithResponse request returning *DeleteGitRepositoryResponse
func (c *ClientWithResponses) DeleteGitRepositoryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteGitRepositoryResponse, error) {
	rsp, err := c.DeleteGitRepository(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGitRepositoryResponse(rsp)
}

// GetGitRepositoryWithResponse request returning *GetGitRepositoryResponse
func (c *ClientWithResponses) GetGitRepositoryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetGitRepositoryResponse, error) {
	rsp, err := c.GetGitRepository(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGitRepositoryResponse(rsp)
}

// UpdateGitRepositoryWithBodyWithResponse request with arbitrary body returning *UpdateGitRepositoryResponse
func (c *ClientWithResponses) UpdateGitRepositoryWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGitRepositoryResponse, error) {
	rsp, err := c.UpdateGitRepositoryWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGitRepositoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateGitRepositoryWithResponse(ctx context.Context, id string, body UpdateGitRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGitRepositoryResponse, error) {
	rsp, err := c.UpdateGitRepository(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGitRepositoryResponse(rsp)
}

// ListGlobalServicesWithResponse request returning *ListGlobalServicesResponse
func (c *ClientWithResponses) ListGlobalServicesWithResponse(ctx context.Context, params *ListGlobalServicesParams, reqEditors ...RequestEditorFn) (*ListGlobalServicesResponse, error) {
	rsp, err := c.ListGlobalServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGlobalServicesResponse(rsp)
}

// CreateGlobalServiceWithBodyWithResponse request with arbitrary body returning *CreateGlobalServiceResponse
func (c *ClientWithResponses) CreateGlobalServiceWithBodyWithResponse(ctx context.Context, params *CreateGlobalServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGlobalServiceResponse, error) {
	rsp, err := c.CreateGlobalServiceWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGlobalServiceResponse(rsp)
}

func (c *ClientWithResponses) CreateGlobalServiceWithResponse(ctx context.Context, params *CreateGlobalServiceParams, body CreateGlobalServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGlobalServiceResponse, error) {
	rsp, err := c.CreateGlobalService(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGlobalServiceResponse(rsp)
}

// DeleteGlobalServiceWithResponse request returning *DeleteGlobalServiceResponse
func (c *ClientWithResponses) DeleteGlobalServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteGlobalServiceResponse, error) {
	rsp, err := c.DeleteGlobalService(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGlobalServiceResponse(rsp)
}

// GetGlobalServiceWithResponse request returning *GetGlobalServiceResponse
func (c *ClientWithResponses) GetGlobalServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetGlobalServiceResponse, error) {
	rsp, err := c.GetGlobalService(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGlobalServiceResponse(rsp)
}

// UpdateGlobalServiceWithBodyWithResponse request with arbitrary body returning *UpdateGlobalServiceResponse
func (c *ClientWithResponses) UpdateGlobalServiceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGlobalServiceResponse, error) {
	rsp, err := c.UpdateGlobalServiceWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGlobalServiceResponse(rsp)
}

func (c *ClientWithResponses) UpdateGlobalServiceWithResponse(ctx context.Context, id string, body UpdateGlobalServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGlobalServiceResponse, error) {
	rsp, err := c.UpdateGlobalService(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGlobalServiceResponse(rsp)
}

// SyncGlobalServiceWithResponse request returning *SyncGlobalServiceResponse
func (c *ClientWithResponses) SyncGlobalServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SyncGlobalServiceResponse, error) {
	rsp, err := c.SyncGlobalService(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncGlobalServiceResponse(rsp)
}

// ListHelmRepositoriesWithResponse request returning *ListHelmRepositoriesResponse
func (c *ClientWithResponses) ListHelmRepositoriesWithResponse(ctx context.Context, params *ListHelmRepositoriesParams, reqEditors ...RequestEditorFn) (*ListHelmRepositoriesResponse, error) {
	rsp, err := c.ListHelmRepositories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHelmRepositoriesResponse(rsp)
}

// UpsertHelmRepositoryWithBodyWithResponse request with arbitrary body returning *UpsertHelmRepositoryResponse
func (c *ClientWithResponses) UpsertHelmRepositoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertHelmRepositoryResponse, error) {
	rsp, err := c.UpsertHelmRepositoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertHelmRepositoryResponse(rsp)
}

func (c *ClientWithResponses) UpsertHelmRepositoryWithResponse(ctx context.Context, body UpsertHelmRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertHelmRepositoryResponse, error) {
	rsp, err := c.UpsertHelmRepository(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertHelmRepositoryResponse(rsp)
}

// GetHelmRepositoryByUrlWithResponse request returning *GetHelmRepositoryByUrlResponse
func (c *ClientWithResponses) GetHelmRepositoryByUrlWithResponse(ctx context.Context, params *GetHelmRepositoryByUrlParams, reqEditors ...RequestEditorFn) (*GetHelmRepositoryByUrlResponse, error) {
	rsp, err := c.GetHelmRepositoryByUrl(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHelmRepositoryByUrlResponse(rsp)
}

// GetHelmRepositoryWithResponse request returning *GetHelmRepositoryResponse
func (c *ClientWithResponses) GetHelmRepositoryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetHelmRepositoryResponse, error) {
	rsp, err := c.GetHelmRepository(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHelmRepositoryResponse(rsp)
}

// ListPipelinesWithResponse request returning *ListPipelinesResponse
func (c *ClientWithResponses) ListPipelinesWithResponse(ctx context.Context, params *ListPipelinesParams, reqEditors ...RequestEditorFn) (*ListPipelinesResponse, error) {
	rsp, err := c.ListPipelines(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPipelinesResponse(rsp)
}

// GetPipelineWithResponse request returning *GetPipelineResponse
func (c *ClientWithResponses) GetPipelineWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPipelineResponse, error) {
	rsp, err := c.GetPipeline(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelineResponse(rsp)
}

// TriggerPipelineWithBodyWithResponse request with arbitrary body returning *TriggerPipelineResponse
func (c *ClientWithResponses) TriggerPipelineWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TriggerPipelineResponse, error) {
	rsp, err := c.TriggerPipelineWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerPipelineResponse(rsp)
}

func (c *ClientWithResponses) TriggerPipelineWithResponse(ctx context.Context, id string, body TriggerPipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*TriggerPipelineResponse, error) {
	rsp, err := c.TriggerPipeline(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerPipelineResponse(rsp)
}

// ListServicesWithResponse request returning *ListServicesResponse
func (c *ClientWithResponses) ListServicesWithResponse(ctx context.Context, params *ListServicesParams, reqEditors ...RequestEditorFn) (*ListServicesResponse, error) {
	rsp, err := c.ListServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServicesResponse(rsp)
}

// CreateServiceWithBodyWithResponse request with arbitrary body returning *CreateServiceResponse
func (c *ClientWithResponses) CreateServiceWithBodyWithResponse(ctx context.Context, params *CreateServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error) {
	rsp, err := c.CreateServiceWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceWithResponse(ctx context.Context, params *CreateServiceParams, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error) {
	rsp, err := c.CreateService(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceResponse(rsp)
}

// DeleteServiceWithResponse request returning *DeleteServiceResponse
func (c *ClientWithResponses) DeleteServiceWithResponse(ctx context.Context, id string, params *DeleteServiceParams, reqEditors ...RequestEditorFn) (*DeleteServiceResponse, error) {
	rsp, err := c.DeleteService(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceResponse(rsp)
}

// GetServiceWithResponse request returning *GetServiceResponse
func (c *ClientWithResponses) GetServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetServiceResponse, error) {
	rsp, err := c.GetService(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceResponse(rsp)
}

// UpdateServiceWithBodyWithResponse request with arbitrary body returning *UpdateServiceResponse
func (c *ClientWithResponses) UpdateServiceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceResponse, error) {
	rsp, err := c.UpdateServiceWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceWithResponse(ctx context.Context, id string, body UpdateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceResponse, error) {
	rsp, err := c.UpdateService(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceResponse(rsp)
}

// MeWithResponse request returning *MeResponse
func (c *ClientWithResponses) MeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MeResponse, error) {
	rsp, err := c.Me(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeResponse(rsp)
}

// ListProjectsWithResponse request returning *ListProjectsResponse
func (c *ClientWithResponses) ListProjectsWithResponse(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error) {
	rsp, err := c.ListProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectsResponse(rsp)
}

// ListCatalogsWithResponse request returning *ListCatalogsResponse
func (c *ClientWithResponses) ListCatalogsWithResponse(ctx context.Context, params *ListCatalogsParams, reqEditors ...RequestEditorFn) (*ListCatalogsResponse, error) {
	rsp, err := c.ListCatalogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCatalogsResponse(rsp)
}

// UpsertCatalogWithBodyWithResponse request with arbitrary body returning *UpsertCatalogResponse
func (c *ClientWithResponses) UpsertCatalogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertCatalogResponse, error) {
	rsp, err := c.UpsertCatalogWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertCatalogResponse(rsp)
}

func (c *ClientWithResponses) UpsertCatalogWithResponse(ctx context.Context, body UpsertCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertCatalogResponse, error) {
	rsp, err := c.UpsertCatalog(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertCatalogResponse(rsp)
}

// ListPrAutomationsForCatalogWithResponse request returning *ListPrAutomationsForCatalogResponse
func (c *ClientWithResponses) ListPrAutomationsForCatalogWithResponse(ctx context.Context, catalogId string, params *ListPrAutomationsForCatalogParams, reqEditors ...RequestEditorFn) (*ListPrAutomationsForCatalogResponse, error) {
	rsp, err := c.ListPrAutomationsForCatalog(ctx, catalogId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPrAutomationsForCatalogResponse(rsp)
}

// DeleteCatalogWithResponse request returning *DeleteCatalogResponse
func (c *ClientWithResponses) DeleteCatalogWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCatalogResponse, error) {
	rsp, err := c.DeleteCatalog(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCatalogResponse(rsp)
}

// GetCatalogWithResponse request returning *GetCatalogResponse
func (c *ClientWithResponses) GetCatalogWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCatalogResponse, error) {
	rsp, err := c.GetCatalog(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogResponse(rsp)
}

// UpdateCatalogWithBodyWithResponse request with arbitrary body returning *UpdateCatalogResponse
func (c *ClientWithResponses) UpdateCatalogWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCatalogResponse, error) {
	rsp, err := c.UpdateCatalogWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCatalogResponse(rsp)
}

func (c *ClientWithResponses) UpdateCatalogWithResponse(ctx context.Context, id string, body UpdateCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCatalogResponse, error) {
	rsp, err := c.UpdateCatalog(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCatalogResponse(rsp)
}

// ListScmConnectionsWithResponse request returning *ListScmConnectionsResponse
func (c *ClientWithResponses) ListScmConnectionsWithResponse(ctx context.Context, params *ListScmConnectionsParams, reqEditors ...RequestEditorFn) (*ListScmConnectionsResponse, error) {
	rsp, err := c.ListScmConnections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListScmConnectionsResponse(rsp)
}

// CreateScmConnectionWithBodyWithResponse request with arbitrary body returning *CreateScmConnectionResponse
func (c *ClientWithResponses) CreateScmConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScmConnectionResponse, error) {
	rsp, err := c.CreateScmConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScmConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateScmConnectionWithResponse(ctx context.Context, body CreateScmConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScmConnectionResponse, error) {
	rsp, err := c.CreateScmConnection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScmConnectionResponse(rsp)
}

// DeleteScmConnectionWithResponse request returning *DeleteScmConnectionResponse
func (c *ClientWithResponses) DeleteScmConnectionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteScmConnectionResponse, error) {
	rsp, err := c.DeleteScmConnection(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteScmConnectionResponse(rsp)
}

// GetScmConnectionWithResponse request returning *GetScmConnectionResponse
func (c *ClientWithResponses) GetScmConnectionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetScmConnectionResponse, error) {
	rsp, err := c.GetScmConnection(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScmConnectionResponse(rsp)
}

// UpdateScmConnectionWithBodyWithResponse request with arbitrary body returning *UpdateScmConnectionResponse
func (c *ClientWithResponses) UpdateScmConnectionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScmConnectionResponse, error) {
	rsp, err := c.UpdateScmConnectionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScmConnectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateScmConnectionWithResponse(ctx context.Context, id string, body UpdateScmConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScmConnectionResponse, error) {
	rsp, err := c.UpdateScmConnection(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScmConnectionResponse(rsp)
}

// ListPrAutomationsWithResponse request returning *ListPrAutomationsResponse
func (c *ClientWithResponses) ListPrAutomationsWithResponse(ctx context.Context, params *ListPrAutomationsParams, reqEditors ...RequestEditorFn) (*ListPrAutomationsResponse, error) {
	rsp, err := c.ListPrAutomations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPrAutomationsResponse(rsp)
}

// GetPrAutomationWithResponse request returning *GetPrAutomationResponse
func (c *ClientWithResponses) GetPrAutomationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPrAutomationResponse, error) {
	rsp, err := c.GetPrAutomation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPrAutomationResponse(rsp)
}

// InvokePrAutomationWithBodyWithResponse request with arbitrary body returning *InvokePrAutomationResponse
func (c *ClientWithResponses) InvokePrAutomationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InvokePrAutomationResponse, error) {
	rsp, err := c.InvokePrAutomationWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInvokePrAutomationResponse(rsp)
}

func (c *ClientWithResponses) InvokePrAutomationWithResponse(ctx context.Context, id string, body InvokePrAutomationJSONRequestBody, reqEditors ...RequestEditorFn) (*InvokePrAutomationResponse, error) {
	rsp, err := c.InvokePrAutomation(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInvokePrAutomationResponse(rsp)
}

// ListPullRequestsWithResponse request returning *ListPullRequestsResponse
func (c *ClientWithResponses) ListPullRequestsWithResponse(ctx context.Context, params *ListPullRequestsParams, reqEditors ...RequestEditorFn) (*ListPullRequestsResponse, error) {
	rsp, err := c.ListPullRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPullRequestsResponse(rsp)
}

// GetPullRequestWithResponse request returning *GetPullRequestResponse
func (c *ClientWithResponses) GetPullRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPullRequestResponse, error) {
	rsp, err := c.GetPullRequest(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPullRequestResponse(rsp)
}

// ListServiceAccountsWithResponse request returning *ListServiceAccountsResponse
func (c *ClientWithResponses) ListServiceAccountsWithResponse(ctx context.Context, params *ListServiceAccountsParams, reqEditors ...RequestEditorFn) (*ListServiceAccountsResponse, error) {
	rsp, err := c.ListServiceAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceAccountsResponse(rsp)
}

// GetServiceAccountByEmailWithResponse request returning *GetServiceAccountByEmailResponse
func (c *ClientWithResponses) GetServiceAccountByEmailWithResponse(ctx context.Context, email openapi_types.Email, reqEditors ...RequestEditorFn) (*GetServiceAccountByEmailResponse, error) {
	rsp, err := c.GetServiceAccountByEmail(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceAccountByEmailResponse(rsp)
}

// GetServiceAccountWithResponse request returning *GetServiceAccountResponse
func (c *ClientWithResponses) GetServiceAccountWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetServiceAccountResponse, error) {
	rsp, err := c.GetServiceAccount(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceAccountResponse(rsp)
}

// CreateServiceAccountAccessTokenWithBodyWithResponse request with arbitrary body returning *CreateServiceAccountAccessTokenResponse
func (c *ClientWithResponses) CreateServiceAccountAccessTokenWithBodyWithResponse(ctx context.Context, id string, params *CreateServiceAccountAccessTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountAccessTokenResponse, error) {
	rsp, err := c.CreateServiceAccountAccessTokenWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceAccountAccessTokenWithResponse(ctx context.Context, id string, params *CreateServiceAccountAccessTokenParams, body CreateServiceAccountAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountAccessTokenResponse, error) {
	rsp, err := c.CreateServiceAccountAccessToken(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountAccessTokenResponse(rsp)
}

// ListStacksWithResponse request returning *ListStacksResponse
func (c *ClientWithResponses) ListStacksWithResponse(ctx context.Context, params *ListStacksParams, reqEditors ...RequestEditorFn) (*ListStacksResponse, error) {
	rsp, err := c.ListStacks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStacksResponse(rsp)
}

// CreateStackWithBodyWithResponse request with arbitrary body returning *CreateStackResponse
func (c *ClientWithResponses) CreateStackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStackResponse, error) {
	rsp, err := c.CreateStackWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStackResponse(rsp)
}

func (c *ClientWithResponses) CreateStackWithResponse(ctx context.Context, body CreateStackJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStackResponse, error) {
	rsp, err := c.CreateStack(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStackResponse(rsp)
}

// DeleteStackWithResponse request returning *DeleteStackResponse
func (c *ClientWithResponses) DeleteStackWithResponse(ctx context.Context, id string, params *DeleteStackParams, reqEditors ...RequestEditorFn) (*DeleteStackResponse, error) {
	rsp, err := c.DeleteStack(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStackResponse(rsp)
}

// GetStackWithResponse request returning *GetStackResponse
func (c *ClientWithResponses) GetStackWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetStackResponse, error) {
	rsp, err := c.GetStack(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStackResponse(rsp)
}

// UpdateStackWithBodyWithResponse request with arbitrary body returning *UpdateStackResponse
func (c *ClientWithResponses) UpdateStackWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStackResponse, error) {
	rsp, err := c.UpdateStackWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStackResponse(rsp)
}

func (c *ClientWithResponses) UpdateStackWithResponse(ctx context.Context, id string, body UpdateStackJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStackResponse, error) {
	rsp, err := c.UpdateStack(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStackResponse(rsp)
}

// RestoreStackWithResponse request returning *RestoreStackResponse
func (c *ClientWithResponses) RestoreStackWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RestoreStackResponse, error) {
	rsp, err := c.RestoreStack(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreStackResponse(rsp)
}

// ResyncStackWithResponse request returning *ResyncStackResponse
func (c *ClientWithResponses) ResyncStackWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ResyncStackResponse, error) {
	rsp, err := c.ResyncStack(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResyncStackResponse(rsp)
}

// TriggerStackRunWithResponse request returning *TriggerStackRunResponse
func (c *ClientWithResponses) TriggerStackRunWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*TriggerStackRunResponse, error) {
	rsp, err := c.TriggerStackRun(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerStackRunResponse(rsp)
}

// ParseListAgentRunsResponse parses an HTTP response from a ListAgentRunsWithResponse call
func ParseListAgentRunsResponse(rsp *http.Response) (*ListAgentRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAgentRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPIAIAgentRunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAgentRunResponse parses an HTTP response from a CreateAgentRunWithResponse call
func ParseCreateAgentRunResponse(rsp *http.Response) (*CreateAgentRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAgentRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AgentRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAgentRunResponse parses an HTTP response from a GetAgentRunWithResponse call
func ParseGetAgentRunResponse(rsp *http.Response) (*GetAgentRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAgentRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AgentRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAgentRuntimesResponse parses an HTTP response from a ListAgentRuntimesWithResponse call
func ParseListAgentRuntimesResponse(rsp *http.Response) (*ListAgentRuntimesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAgentRuntimesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPIAIAgentRuntimeList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAgentRuntimeResponse parses an HTTP response from a GetAgentRuntimeWithResponse call
func ParseGetAgentRuntimeResponse(rsp *http.Response) (*GetAgentRuntimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAgentRuntimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AgentRuntime
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSentinelRunResponse parses an HTTP response from a GetSentinelRunWithResponse call
func ParseGetSentinelRunResponse(rsp *http.Response) (*GetSentinelRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSentinelRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SentinelRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSentinelsResponse parses an HTTP response from a ListSentinelsWithResponse call
func ParseListSentinelsResponse(rsp *http.Response) (*ListSentinelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSentinelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPIAISentinelList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSentinelResponse parses an HTTP response from a GetSentinelWithResponse call
func ParseGetSentinelResponse(rsp *http.Response) (*GetSentinelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSentinelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sentinel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTriggerSentinelResponse parses an HTTP response from a TriggerSentinelWithResponse call
func ParseTriggerSentinelResponse(rsp *http.Response) (*TriggerSentinelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TriggerSentinelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SentinelRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSentinelRunsResponse parses an HTTP response from a ListSentinelRunsWithResponse call
func ParseListSentinelRunsResponse(rsp *http.Response) (*ListSentinelRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSentinelRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPIAISentinelRunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAgentSessionsResponse parses an HTTP response from a ListAgentSessionsWithResponse call
func ParseListAgentSessionsResponse(rsp *http.Response) (*ListAgentSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAgentSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPIAIAgentSessionList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAgentSessionResponse parses an HTTP response from a CreateAgentSessionWithResponse call
func ParseCreateAgentSessionResponse(rsp *http.Response) (*CreateAgentSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAgentSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AgentSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAgentSessionResponse parses an HTTP response from a GetAgentSessionWithResponse call
func ParseGetAgentSessionResponse(rsp *http.Response) (*GetAgentSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAgentSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AgentSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListClustersResponse parses an HTTP response from a ListClustersWithResponse call
func ParseListClustersResponse(rsp *http.Response) (*ListClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPICDClusterList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateClusterResponse parses an HTTP response from a CreateClusterWithResponse call
func ParseCreateClusterResponse(rsp *http.Response) (*CreateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateClusterResponse parses an HTTP response from a UpdateClusterWithResponse call
func ParseUpdateClusterResponse(rsp *http.Response) (*UpdateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateClusterUpgradeResponse parses an HTTP response from a CreateClusterUpgradeWithResponse call
func ParseCreateClusterUpgradeResponse(rsp *http.Response) (*CreateClusterUpgradeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterUpgradeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterUpgrade
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClusterUpgradeResponse parses an HTTP response from a GetClusterUpgradeWithResponse call
func ParseGetClusterUpgradeResponse(rsp *http.Response) (*GetClusterUpgradeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterUpgradeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterUpgrade
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListGitRepositoriesResponse parses an HTTP response from a ListGitRepositoriesWithResponse call
func ParseListGitRepositoriesResponse(rsp *http.Response) (*ListGitRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGitRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPICDGitRepositoryList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateGitRepositoryResponse parses an HTTP response from a CreateGitRepositoryWithResponse call
func ParseCreateGitRepositoryResponse(rsp *http.Response) (*CreateGitRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGitRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGitRepositoryByUrlResponse parses an HTTP response from a GetGitRepositoryByUrlWithResponse call
func ParseGetGitRepositoryByUrlResponse(rsp *http.Response) (*GetGitRepositoryByUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGitRepositoryByUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteGitRepositoryResponse parses an HTTP response from a DeleteGitRepositoryWithResponse call
func ParseDeleteGitRepositoryResponse(rsp *http.Response) (*DeleteGitRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGitRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGitRepositoryResponse parses an HTTP response from a GetGitRepositoryWithResponse call
func ParseGetGitRepositoryResponse(rsp *http.Response) (*GetGitRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGitRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateGitRepositoryResponse parses an HTTP response from a UpdateGitRepositoryWithResponse call
func ParseUpdateGitRepositoryResponse(rsp *http.Response) (*UpdateGitRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGitRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListGlobalServicesResponse parses an HTTP response from a ListGlobalServicesWithResponse call
func ParseListGlobalServicesResponse(rsp *http.Response) (*ListGlobalServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGlobalServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPICDGlobalServiceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateGlobalServiceResponse parses an HTTP response from a CreateGlobalServiceWithResponse call
func ParseCreateGlobalServiceResponse(rsp *http.Response) (*CreateGlobalServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGlobalServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteGlobalServiceResponse parses an HTTP response from a DeleteGlobalServiceWithResponse call
func ParseDeleteGlobalServiceResponse(rsp *http.Response) (*DeleteGlobalServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGlobalServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGlobalServiceResponse parses an HTTP response from a GetGlobalServiceWithResponse call
func ParseGetGlobalServiceResponse(rsp *http.Response) (*GetGlobalServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGlobalServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateGlobalServiceResponse parses an HTTP response from a UpdateGlobalServiceWithResponse call
func ParseUpdateGlobalServiceResponse(rsp *http.Response) (*UpdateGlobalServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGlobalServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSyncGlobalServiceResponse parses an HTTP response from a SyncGlobalServiceWithResponse call
func ParseSyncGlobalServiceResponse(rsp *http.Response) (*SyncGlobalServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncGlobalServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalService
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListHelmRepositoriesResponse parses an HTTP response from a ListHelmRepositoriesWithResponse call
func ParseListHelmRepositoriesResponse(rsp *http.Response) (*ListHelmRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHelmRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPICDHelmRepositoryList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpsertHelmRepositoryResponse parses an HTTP response from a UpsertHelmRepositoryWithResponse call
func ParseUpsertHelmRepositoryResponse(rsp *http.Response) (*UpsertHelmRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertHelmRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HelmRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHelmRepositoryByUrlResponse parses an HTTP response from a GetHelmRepositoryByUrlWithResponse call
func ParseGetHelmRepositoryByUrlResponse(rsp *http.Response) (*GetHelmRepositoryByUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHelmRepositoryByUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HelmRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHelmRepositoryResponse parses an HTTP response from a GetHelmRepositoryWithResponse call
func ParseGetHelmRepositoryResponse(rsp *http.Response) (*GetHelmRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHelmRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HelmRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPipelinesResponse parses an HTTP response from a ListPipelinesWithResponse call
func ParseListPipelinesResponse(rsp *http.Response) (*ListPipelinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPipelinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPICDPipelineList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPipelineResponse parses an HTTP response from a GetPipelineWithResponse call
func ParseGetPipelineResponse(rsp *http.Response) (*GetPipelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Pipeline
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTriggerPipelineResponse parses an HTTP response from a TriggerPipelineWithResponse call
func ParseTriggerPipelineResponse(rsp *http.Response) (*TriggerPipelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TriggerPipelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PipelineContext
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListServicesResponse parses an HTTP response from a ListServicesWithResponse call
func ParseListServicesResponse(rsp *http.Response) (*ListServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPICDServiceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateServiceResponse parses an HTTP response from a CreateServiceWithResponse call
func ParseCreateServiceResponse(rsp *http.Response) (*CreateServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteServiceResponse parses an HTTP response from a DeleteServiceWithResponse call
func ParseDeleteServiceResponse(rsp *http.Response) (*DeleteServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServiceResponse parses an HTTP response from a GetServiceWithResponse call
func ParseGetServiceResponse(rsp *http.Response) (*GetServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateServiceResponse parses an HTTP response from a UpdateServiceWithResponse call
func ParseUpdateServiceResponse(rsp *http.Response) (*UpdateServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeResponse parses an HTTP response from a MeWithResponse call
func ParseMeResponse(rsp *http.Response) (*MeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListProjectsResponse parses an HTTP response from a ListProjectsWithResponse call
func ParseListProjectsResponse(rsp *http.Response) (*ListProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPIProjectList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCatalogsResponse parses an HTTP response from a ListCatalogsWithResponse call
func ParseListCatalogsResponse(rsp *http.Response) (*ListCatalogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCatalogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPISCMCatalogList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpsertCatalogResponse parses an HTTP response from a UpsertCatalogWithResponse call
func ParseUpsertCatalogResponse(rsp *http.Response) (*UpsertCatalogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertCatalogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Catalog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPrAutomationsForCatalogResponse parses an HTTP response from a ListPrAutomationsForCatalogWithResponse call
func ParseListPrAutomationsForCatalogResponse(rsp *http.Response) (*ListPrAutomationsForCatalogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPrAutomationsForCatalogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPISCMPrAutomationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCatalogResponse parses an HTTP response from a DeleteCatalogWithResponse call
func ParseDeleteCatalogResponse(rsp *http.Response) (*DeleteCatalogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCatalogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Catalog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCatalogResponse parses an HTTP response from a GetCatalogWithResponse call
func ParseGetCatalogResponse(rsp *http.Response) (*GetCatalogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Catalog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCatalogResponse parses an HTTP response from a UpdateCatalogWithResponse call
func ParseUpdateCatalogResponse(rsp *http.Response) (*UpdateCatalogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCatalogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Catalog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListScmConnectionsResponse parses an HTTP response from a ListScmConnectionsWithResponse call
func ParseListScmConnectionsResponse(rsp *http.Response) (*ListScmConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListScmConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPISCMConnectionList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateScmConnectionResponse parses an HTTP response from a CreateScmConnectionWithResponse call
func ParseCreateScmConnectionResponse(rsp *http.Response) (*CreateScmConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateScmConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScmConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteScmConnectionResponse parses an HTTP response from a DeleteScmConnectionWithResponse call
func ParseDeleteScmConnectionResponse(rsp *http.Response) (*DeleteScmConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteScmConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScmConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScmConnectionResponse parses an HTTP response from a GetScmConnectionWithResponse call
func ParseGetScmConnectionResponse(rsp *http.Response) (*GetScmConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScmConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScmConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateScmConnectionResponse parses an HTTP response from a UpdateScmConnectionWithResponse call
func ParseUpdateScmConnectionResponse(rsp *http.Response) (*UpdateScmConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateScmConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScmConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPrAutomationsResponse parses an HTTP response from a ListPrAutomationsWithResponse call
func ParseListPrAutomationsResponse(rsp *http.Response) (*ListPrAutomationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPrAutomationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPISCMPrAutomationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPrAutomationResponse parses an HTTP response from a GetPrAutomationWithResponse call
func ParseGetPrAutomationResponse(rsp *http.Response) (*GetPrAutomationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPrAutomationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrAutomation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInvokePrAutomationResponse parses an HTTP response from a InvokePrAutomationWithResponse call
func ParseInvokePrAutomationResponse(rsp *http.Response) (*InvokePrAutomationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InvokePrAutomationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPullRequestsResponse parses an HTTP response from a ListPullRequestsWithResponse call
func ParseListPullRequestsResponse(rsp *http.Response) (*ListPullRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPullRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPISCMPullRequestList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPullRequestResponse parses an HTTP response from a GetPullRequestWithResponse call
func ParseGetPullRequestResponse(rsp *http.Response) (*GetPullRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPullRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListServiceAccountsResponse parses an HTTP response from a ListServiceAccountsWithResponse call
func ParseListServiceAccountsResponse(rsp *http.Response) (*ListServiceAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPIUserList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServiceAccountByEmailResponse parses an HTTP response from a GetServiceAccountByEmailWithResponse call
func ParseGetServiceAccountByEmailResponse(rsp *http.Response) (*GetServiceAccountByEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceAccountByEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServiceAccountResponse parses an HTTP response from a GetServiceAccountWithResponse call
func ParseGetServiceAccountResponse(rsp *http.Response) (*GetServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateServiceAccountAccessTokenResponse parses an HTTP response from a CreateServiceAccountAccessTokenWithResponse call
func ParseCreateServiceAccountAccessTokenResponse(rsp *http.Response) (*CreateServiceAccountAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceAccountAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListStacksResponse parses an HTTP response from a ListStacksWithResponse call
func ParseListStacksResponse(rsp *http.Response) (*ListStacksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStacksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsoleOpenAPIStackList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateStackResponse parses an HTTP response from a CreateStackWithResponse call
func ParseCreateStackResponse(rsp *http.Response) (*CreateStackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Stack
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteStackResponse parses an HTTP response from a DeleteStackWithResponse call
func ParseDeleteStackResponse(rsp *http.Response) (*DeleteStackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Stack
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStackResponse parses an HTTP response from a GetStackWithResponse call
func ParseGetStackResponse(rsp *http.Response) (*GetStackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Stack
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateStackResponse parses an HTTP response from a UpdateStackWithResponse call
func ParseUpdateStackResponse(rsp *http.Response) (*UpdateStackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Stack
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRestoreStackResponse parses an HTTP response from a RestoreStackWithResponse call
func ParseRestoreStackResponse(rsp *http.Response) (*RestoreStackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Stack
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResyncStackResponse parses an HTTP response from a ResyncStackWithResponse call
func ParseResyncStackResponse(rsp *http.Response) (*ResyncStackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResyncStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StackRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTriggerStackRunResponse parses an HTTP response from a TriggerStackRunWithResponse call
func ParseTriggerStackRunResponse(rsp *http.Response) (*TriggerStackRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TriggerStackRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StackRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
